## 前言
{: id="20210330211656-fe97mla"}

这是我的第二篇专门介绍如何去学习某个知识点的文章，在上一篇[《写给 Java 程序员看的算法学习指南！》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486508&idx=1&sn=ce2faafcde166d5412d7166a01fdc1e9&chksm=cea243e7f9d5caf1dbf4d6ccf0438a1731bc0070310bba1ac481d485e4a6756349c20f02a6b1&token=211950660&lang=zh_CN#rd) 的文章中，我推荐了一些关于 **算法学习的书籍以及资源** 。
{: id="20210330211656-dljpuvb"}

相比于写技术文章来说，写这种这种类型的文章实际花费的时间可能会稍微少一点。但是，这种学习指南形式的文章，我想对于 Java 初学者甚至是工作几年的 Java 工程师来说应该还是非常有帮助的！
{: id="20210330211656-ufdf58r"}

我们都知道多线程应该是大部分 Java 程序员最难啃的一块骨头之一，这部分内容的难度跨度大，难实践，并且市面上的参考资料的质量也层次不齐。
{: id="20210330211656-2wbg2k3"}

在这篇文章中，我会首先介绍一下 **Java 多线程学习** 中比较重要的一些问题，然后还会推荐一些比较不错的学习资源供大家参考。希望对你们学习多线程相关的知识能有帮助。以下介绍的很多知识点你都可以在这里找到：[https://snailclimb.gitee.io/javaguide/#/?id=并发](https://snailclimb.gitee.io/javaguide/#/?id=并发)
{: id="20210330211656-w2r6mmj"}

![](images/多线程学习指南/javaguide-并发.png)
{: id="20210330211656-jhp4goy"}

**另外，我还将本文的内容同步到了 Github 上，点击阅读原文即可直达。如果你觉得有任何需要完善和修改的地方，都可以去 Github 给我提交 Issue 或者 PR（推荐）。**
{: id="20210330211656-8rkm6bw"}

## 一.Java 多线程知识点总结
{: id="20210330211656-b53mqdt"}

### 1.1.多线程基础
{: id="20210330211656-2kwsnhb"}

1. {: id="20210330211656-ezzrc4r"}什么是线程和进程? 线程与进程的关系,区别及优缺点？
   {: id="20210330211656-ad3r34a"}
2. {: id="20210330211656-mrepu6i"}说说并发与并行的区别?
   {: id="20210330211656-3y7amsh"}
3. {: id="20210330211656-7nqf4hc"}为什么要使用多线程呢?
   {: id="20210330211656-mcbmnef"}
4. {: id="20210330211656-g1hny7w"}使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）
   {: id="20210330211656-8nc8j0c"}
5. {: id="20210330211656-8mja96g"}创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）
   {: id="20210330211656-75o6jc1"}
6. {: id="20210330211656-ht0i4cq"}说说线程的生命周期和状态?
   {: id="20210330211656-gpv9ekc"}
7. {: id="20210330211656-z5vgtx1"}什么是上下文切换?
   {: id="20210330211656-8vwupfq"}
8. {: id="20210330211656-vo143vt"}什么是线程死锁?如何避免死锁?
   {: id="20210330211656-5ul7mgn"}
9. {: id="20210330211656-sto07tu"}说说 sleep() 方法和 wait() 方法区别和共同点?
   {: id="20210330211656-52ghht9"}
10. {: id="20210330211656-c29y6ga"}为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
    {: id="20210330211656-wc46bbx"}
11. {: id="20210330211656-ncarcu6"}......
    {: id="20210330211656-vsc94h1"}
{: id="20210330211656-x4azsri"}

### 1.2.多线程知识进阶
{: id="20210330211656-rrox173"}

#### volatile 关键字
{: id="20210330211656-dtd72qc"}

1. {: id="20210330211656-820039x"}Java 内存模型（**JMM**）;
   {: id="20210330211656-kzavf72"}
2. {: id="20210330211656-2mfbjo9"}重排序与 happens-before 原则了解吗?
   {: id="20210330211656-92lxuu5"}
3. {: id="20210330211656-djvq51d"}volatile 关键字的作用;
   {: id="20210330211656-nt716r6"}
4. {: id="20210330211656-mn7h9bb"}说说 synchronized 关键字和 volatile 关键字的区别;
   {: id="20210330211656-0y9is0h"}
5. {: id="20210330211656-jzjf9gu"}......
   {: id="20210330211656-joxl6ug"}
{: id="20210330211656-wvol2sy"}

#### ThreadLocal
{: id="20210330211656-a60mi8r"}

1. {: id="20210330211656-rmvd4sa"}有啥用（解决了什么问题）？怎么用？
   {: id="20210330211656-vpiqxgl"}
2. {: id="20210330211656-ixi5l9y"}原理了解吗？
   {: id="20210330211656-w5hfiq2"}
3. {: id="20210330211656-4btkd39"}内存泄露问题了解吗？
   {: id="20210330211656-ooteawh"}
{: id="20210330211656-mpcbogg"}

#### 线程池
{: id="20210330211656-080lx16"}

1. {: id="20210330211656-taar4cf"}为什么要用线程池？
   {: id="20210330211656-ldw5keg"}
2. {: id="20210330211656-7fswvt5"}你会使用线程池吗？
   {: id="20210330211656-dk5ozbd"}
3. {: id="20210330211656-xtoqn3y"}如何创建线程池比较好？ （推荐使用 `ThreadPoolExecutor` 构造函数创建线程池）
   {: id="20210330211656-nnosvpg"}
4. {: id="20210330211656-my8z3kn"}`ThreadPoolExecutor` 类的重要参数了解吗？`ThreadPoolExecutor` 饱和策略了解吗？
   {: id="20210330211656-vwbsyzi"}
5. {: id="20210330211656-0truxzq"}线程池原理了解吗？
   {: id="20210330211656-4rcoyo4"}
6. {: id="20210330211656-ch99hm7"}几种常见的线程池了解吗？为什么不推荐使用`FixedThreadPool`？
   {: id="20210330211656-zgn9lc0"}
7. {: id="20210330211656-9j7ttlf"}如何设置线程池的大小？
   {: id="20210330211656-3cm86xh"}
8. {: id="20210330211656-fyq8j9o"}......
   {: id="20210330211656-tq78nvo"}
{: id="20210330211656-udewrfa"}

#### AQS
{: id="20210330211656-9n4a05a"}

1. {: id="20210330211656-sis673h"}简介
   {: id="20210330211656-k1eluou"}
2. {: id="20210330211656-k018yiy"}原理
   {: id="20210330211656-1u0l3hs"}
3. {: id="20210330211656-5ozy25j"}AQS 常用组件。
   {: id="20210330211656-dlk1x54"}
   - {: id="20210330211656-x1lijv0"}**Semaphore(信号量)**-允许多个线程同时访问
     {: id="20210330211656-hu13q46"}
   - {: id="20210330211656-nshsgee"}**CountDownLatch （倒计时器）**-CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。
     {: id="20210330211656-0h4cgly"}
   - {: id="20210330211656-w5xxe5f"}**CyclicBarrier(循环栅栏)**-CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。
     {: id="20210330211656-qngdfik"}
   - {: id="20210330211656-2fwcv43"}**ReentrantLock 和 ReentrantReadWriteLock**
     {: id="20210330211656-mkvygsr"}
   - {: id="20210330211656-bolqc84"}......
     {: id="20210330211656-dpfl05h"}
   {: id="20210330211656-sz4rfru"}
{: id="20210330211656-taul70j"}

#### 锁
{: id="20210330211656-pul9jih"}

锁的常见分类
{: id="20210330211656-xjutda6"}

1. {: id="20210330211656-1c825in"}可重入锁和非可重入锁
   {: id="20210330211656-z082xjj"}
2. {: id="20210330211656-nivuqhc"}公平锁与非公平锁
   {: id="20210330211656-ivdjyzf"}
3. {: id="20210330211656-sxlqt0z"}读写锁和排它锁
   {: id="20210330211656-38qwc5c"}
{: id="20210330211656-d02mlwl"}

**synchronized 关键字**
{: id="20210330211656-v6q191j"}

1. {: id="20210330211656-d37nqy7"}说一说自己对于 synchronized 关键字的了解；
   {: id="20210330211656-qoi7py4"}
2. {: id="20210330211656-6ozivja"}说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;
   {: id="20210330211656-ouwl87u"}
3. {: id="20210330211656-yq0oitj"}讲一下 synchronized 关键字的底层原理；
   {: id="20210330211656-8e3o9pa"}
4. {: id="20210330211656-s51rod8"}说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗；
   {: id="20210330211656-rf8ohjq"}
5. {: id="20210330211656-eyqooxf"}谈谈 synchronized 和 ReentrantLock 的区别；
   {: id="20210330211656-x1tpj6u"}
6. {: id="20210330211656-tc217ca"}......
   {: id="20210330211656-0u2bzdo"}
{: id="20210330211656-n9tuq4d"}

**ReentrantLock 和 ReentrantReadWriteLock**
{: id="20210330211656-c4kuyzc"}

**ReadWriteLock**
{: id="20210330211656-3ndub0p"}

**StampedLock（JDK8）**
{: id="20210330211656-cjcjn9l"}

#### **Atomic 与 CAS**
{: id="20210330211656-hvrwq3j"}

**CAS:**
{: id="20210330211656-c9xn0v7"}

1. {: id="20210330211656-1bma7bw"}介绍
   {: id="20210330211656-aenwp7r"}
2. {: id="20210330211656-4bjch19"}原理
   {: id="20210330211656-7u3jgns"}
{: id="20210330211656-3w1n61b"}

**Atomic 原子类：**
{: id="20210330211656-b5gevxg"}

1. {: id="20210330211656-wvjb1lf"}介绍一下 Atomic 原子类；
   {: id="20210330211656-j1e4h35"}
2. {: id="20210330211656-mk44rpb"}JUC 包中的原子类是哪 4 类?；
   {: id="20210330211656-i88r1ge"}
3. {: id="20210330211656-5oyc1va"}讲讲 AtomicInteger 的使用；
   {: id="20210330211656-okgmvw7"}
4. {: id="20210330211656-1aryz3n"}能不能给我简单介绍一下 AtomicInteger 类的原理。
   {: id="20210330211656-p0ea4ul"}
5. {: id="20210330211656-ej8jv9d"}......
   {: id="20210330211656-t1uumpj"}
{: id="20210330211656-c1hlb4r"}

#### 并发容器
{: id="20210330211656-mk57uo3"}

JDK 提供的这些容器大部分在 `java.util.concurrent` 包中。
{: id="20210330211656-ybk0pm4"}

- {: id="20210330211656-9bd1fbq"}**ConcurrentHashMap:** 线程安全的 HashMap
  {: id="20210330211656-diwdd8v"}
- {: id="20210330211656-enuhnoi"}**CopyOnWriteArrayList:** 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.
  {: id="20210330211656-ie5dgsf"}
- {: id="20210330211656-9jq31wa"}**ConcurrentLinkedQueue:** 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
  {: id="20210330211656-kgc2ods"}
- {: id="20210330211656-s7u8zdv"}**BlockingQueue:** 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
  {: id="20210330211656-inxn9n7"}
- {: id="20210330211656-u2mklww"}**ConcurrentSkipListMap:** 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。
  {: id="20210330211656-nks65s8"}
- {: id="20210330211656-ye84f85"}......
  {: id="20210330211656-2eidl68"}
{: id="20210330211656-36lormw"}

#### Future 和 CompletableFuture
{: id="20210330211656-41c3nnt"}

## 二.书籍推荐
{: id="20210330211656-jmid3br"}

#### 《Java 并发编程之美》
{: id="20210330211656-0hohex0"}

![《Java 并发编程之美》](images/多线程学习指南/java并发编程之美.png)
{: id="20210330211656-tqk3axo"}

**我觉得这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。**
{: id="20210330211656-9xixyco"}

另外，这本书的作者加多自身也会经常在网上发布各种技术文章。我觉得这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！
{: id="20210330211656-vvp26cx"}

#### 《实战 Java 高并发程序设计》
{: id="20210330211656-k13gxk5"}

![《实战 Java 高并发程序设计》](images/多线程学习指南/实战Java高并发程序设计.png)
{: id="20210330211656-yk0rseu"}

这个是我第二本要推荐的书籍，比较适合作为多线程入门/进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。
{: id="20210330211656-i62dxa8"}

#### 《深入浅出 Java 多线程》
{: id="20210330211656-b43x7dp"}

![《深入浅出Java多线程》](images/多线程学习指南/深入浅出Java多线程.png)
{: id="20210330211656-aucr4ju"}

这本书是几位大厂（如阿里）的大佬开源的，Github 地址：[https://github.com/RedSpider1/concurrent](https://github.com/RedSpider1/concurrent)
{: id="20210330211656-zbgbnl2"}

几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。
{: id="20210330211656-x3foxmt"}

这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。
{: id="20210330211656-sxvqnrt"}

#### 《Java 并发编程的艺术》
{: id="20210330211656-2txzqum"}

![《Java 并发编程的艺术》](images/多线程学习指南/Java并发编程的艺术.png)
{: id="20210330211656-r8s8s2w"}

这本书不是很适合作为 Java 多线程入门书籍，需要具备一定的 JVM 基础，有些东西讲的还是挺深入的。另外，就我自己阅读这本书的感觉来说，我觉得这本书的章节规划有点杂乱，但是，具体到某个知识点又很棒！这可能也和这本书由三名作者共同编写完成有关系吧！
{: id="20210330211656-6kmbumr"}

**综上：这本书并不是和 Java 多线程入门，你也不需要把这本书的每一章节都看一遍，建议挑选自己想要详细了解的知识点来看。**
{: id="20210330211656-7b41c0b"}

## 三.总结
{: id="20210330211656-xxxui3b"}

在这篇文章中我主要总结了 Java 多线程方面的知识点，并且推荐了相关的书籍。并发这部分东西实战的话比较难，你可以尝试学会了某个知识点之后然后在自己写过的一些项目上实践。另外，leetcode 有一个练习多线程的类别： [https://leetcode-cn.com/problemset/concurrency](https://leetcode-cn.com/problemset/concurrency) 可以作为参考。
{: id="20210330211656-3wy7cor"}

**为了这篇文章的内容更加完善，我还将本文的内容同步到了 Github 上，点击阅读原文即可直达。如果你觉得有任何需要完善和修改的地方，都可以去 Github 给我提交 Issue 或者 PR（推荐）。**
{: id="20210330211656-hoylj7g"}


{: id="20210330211656-7jb5vwy" type="doc"}
