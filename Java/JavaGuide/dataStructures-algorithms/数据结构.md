> 注意！！！这部分内容会进行重构，以下内容仅作为参考。
> {: id="20210330211653-jidhttl" updated="20210401230325"}
{: id="20210330211653-sy0eokq"}

## Queue
{: id="20210330211653-jnh2ir2"}

### 什么是队列
{: id="20210330211653-niq488k"}

队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。
{: id="20210330211653-f736h1y"}

### 队列的种类
{: id="20210330211653-kk1xqii"}

- {: id="20210330211653-s2jhlga"}**单队列**（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）
  {: id="20210330211653-rr1snuz"}
- {: id="20210330211653-fljfltt"}**循环队列**（避免了“假溢出”的问题）
  {: id="20210330211653-s9ya3wu"}
{: id="20210330211653-ln445tf"}

### Java 集合框架中的队列 Queue
{: id="20210330211653-paod5lg"}

Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。
Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。
除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。
{: id="20210330211653-5296d1y"}

## Set
{: id="20210330211653-gtjaw1y"}

### 什么是 Set
{: id="20210330211653-j7fqcd6"}

Set 继承于 Collection 接口，是一个不允许出现重复元素，并且无序的集合，主要 HashSet 和 TreeSet 两大实现类。
{: id="20210330211653-iqduoan"}

在判断重复元素的时候，HashSet 集合会调用 hashCode()和 equal()方法来实现；TreeSet 集合会调用compareTo方法来实现。
{: id="20210330211653-ejkvo8y"}

### 补充：有序集合与无序集合说明
{: id="20210330211653-456cmdr"}

- {: id="20210330211653-mn96tht"}有序集合：集合里的元素可以根据 key 或 index 访问 (List、Map)
  {: id="20210330211653-w05gf4a"}
- {: id="20210330211653-frkhkft"}无序集合：集合里的元素只能遍历。（Set）
  {: id="20210330211653-qo4zb9h"}
{: id="20210330211653-cni28zp"}

### HashSet 和 TreeSet 底层数据结构
{: id="20210330211653-5hvj8jc"}

**HashSet** 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中的位置；
{: id="20210330211653-j7ik4zv"}

**TreeSet** 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；
{: id="20210330211653-jcpes3x"}

## List
{: id="20210330211653-7fuwvdx"}

### 什么是List
{: id="20210330211653-plrbkyb"}

在 List 中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合而 Set 是无序集合。
{: id="20210330211653-ijlzf8e"}

### List的常见实现类
{: id="20210330211653-bm2quge"}

**ArrayList** 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。
{: id="20210330211653-ugr1di2"}

**LinkedList** 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。
{: id="20210330211653-o3cwtvi"}

**Vector** 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。
{: id="20210330211653-yod5pvn"}

**Stack** 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。
{: id="20210330211653-0jd0oyy"}

## 树
{: id="20210330211653-jzh5ogm"}

### 1 二叉树
{: id="20210330211653-x18qtpz"}

[二叉树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91)（百度百科）
{: id="20210330211653-pjoxvpb"}

(1)[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
{: id="20210330211653-9cjs5iq"}

(2)[满二叉树](https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
{: id="20210330211653-q2mzzh3"}

(3)[平衡二叉树](https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057)——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
{: id="20210330211653-run8avd"}

### 2 完全二叉树
{: id="20210330211653-7iz1qjp"}

[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)（百度百科）
{: id="20210330211653-tz32bq6"}

完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
{: id="20210330211653-l5pxhl4"}

### 3 满二叉树
{: id="20210330211653-86knq1v"}

[满二叉树](https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)（百度百科，国内外的定义不同）
{: id="20210330211653-0cfiwhj"}

国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
{: id="20210330211653-gbvl7nt"}

### 堆
{: id="20210330211653-m8cqfv8"}

[数据结构之堆的定义](https://blog.csdn.net/qq_33186366/article/details/51876191)
{: id="20210330211653-a0yrs59"}

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
{: id="20210330211653-p2abx1b"}

### 4 二叉查找树（BST）
{: id="20210330211653-uawb6yr"}

[浅谈算法和数据结构: 七 二叉查找树](https://www.yycoding.xyz/post/2014/3/24/introduce-binary-search-tree)
{: id="20210330211653-0wsb6ms"}

二叉查找树的特点：
{: id="20210330211653-s5yxmib"}

1. {: id="20210330211653-woi72so"}若任意节点的左子树不空，则左子树上所有结点的     值均小于它的根结点的值；
   {: id="20210330211653-tzi480j"}
2. {: id="20210330211653-8etxvyq"}若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   {: id="20210330211653-gg4ycvf"}
3. {: id="20210330211653-3bk82u8"}任意节点的左、右子树也分别为二叉查找树；
   {: id="20210330211653-9morqbo"}
4. {: id="20210330211653-rsttp17"}没有键值相等的节点（no duplicate nodes）。
   {: id="20210330211653-19t2lpn"}
{: id="20210330211653-gxzz5ob"}

### 5 平衡二叉树（Self-balancing binary search tree）
{: id="20210330211653-9pzpox8"}

[ 平衡二叉树](https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）
{: id="20210330211653-sq9xb1q"}

### 6 红黑树
{: id="20210330211653-yfytew4"}

红黑树特点:
{: id="20210330211653-nfmmlqp"}

1. {: id="20210330211653-9tpg939"}每个节点非红即黑；
   {: id="20210330211653-j6ly1t6"}
2. {: id="20210330211653-ijxvduz"}根节点总是黑色的；
   {: id="20210330211653-zzkpi8m"}
3. {: id="20210330211653-ysw2a00"}每个叶子节点都是黑色的空节点（NIL节点）；
   {: id="20210330211653-38tyr7n"}
4. {: id="20210330211653-7p1pqf0"}如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
   {: id="20210330211653-28mup4t"}
5. {: id="20210330211653-v8qdcgk"}从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。
   {: id="20210330211653-d870sys"}
{: id="20210330211653-77nlmtc"}

红黑树的应用：
{: id="20210330211653-sr9gm1q"}

TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。
{: id="20210330211653-mgihycv"}

**为什么要用红黑树？**
{: id="20210330211653-6nlpehr"}

简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 [漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248#comment)（也介绍到了二叉查找树，非常推荐）
{: id="20210330211653-u8qnq4q"}

推荐文章：
{: id="20210330211653-hvdo1rf"}

- {: id="20210330211653-dpoyjp3"}[漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248#comment)（也介绍到了二叉查找树，非常推荐）
  {: id="20210330211653-wgqkddj"}
- {: id="20210330211653-43p2vfo"}[寻找红黑树的操作手册](http://dandanlove.com/2018/03/18/red-black-tree/)（文章排版以及思路真的不错）
  {: id="20210330211653-bnrdgi4"}
- {: id="20210330211653-iku5et9"}[红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)（美团点评技术团队）
  {: id="20210330211653-n2hc4px"}
{: id="20210330211653-edg48al"}

### 7 B-，B+，B*树
{: id="20210330211653-m286783"}

[二叉树学习笔记之B树、B+树、B*树 ](https://yq.aliyun.com/articles/38345)
{: id="20210330211653-jhxc8og"}

[《B-树，B+树，B*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)
{: id="20210330211653-iyfmzp3"}

[《B-树，B+树与B*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)
{: id="20210330211653-tw2gie9"}

B-树（或B树）是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)
{: id="20210330211653-pc4p9ho"}

1. {: id="20210330211653-djp2mr4"}B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。
   {: id="20210330211653-kgxzarz"}
2. {: id="20210330211653-kpxh9zh"}B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
   {: id="20210330211653-2z0vlxo"}
3. {: id="20210330211653-9bj1ya1"}B\*树 是B+树的变体，B\*树分配新结点的概率比B+树要低，空间使用率更高；
   {: id="20210330211653-hu8p8ux"}
{: id="20210330211653-51euf3h"}

### 8 LSM 树
{: id="20210330211653-xxdtyky"}

[[HBase] LSM树 VS B+树](https://blog.csdn.net/dbanote/article/details/8897599)
{: id="20210330211653-qxrqyde"}

B+树最大的性能问题是会产生大量的随机IO
{: id="20210330211653-7w67fk5"}

为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。
{: id="20210330211653-re65zo8"}

[LSM树由来、设计思想以及应用到HBase的索引](http://www.cnblogs.com/yanghuahui/p/3483754.html)
{: id="20210330211653-o5aq8oh"}

## 图
{: id="20210330211653-lm94lwy"}

## BFS及DFS
{: id="20210330211653-77u1zf4"}

- {: id="20210330211653-nmkoaly"}[《使用BFS及DFS遍历树和图的思路及实现》](https://blog.csdn.net/Gene1994/article/details/85097507)
  {: id="20210330211653-n9tgl94"}
{: id="20210330211653-fqbe6pc"}


{: id="20210330211653-6blhnhu" type="doc"}
