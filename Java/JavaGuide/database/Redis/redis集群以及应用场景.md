相关阅读：
{: id="20210330211654-mj0m6b4"}

- {: id="20210330211654-7q7n46l"}[史上最全Redis高可用技术解决方案大全](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484850&idx=1&sn=3238360bfa8105cf758dcf7354af2814&chksm=cea24a79f9d5c36fb2399aafa91d7fb2699b5006d8d037fe8aaf2e5577ff20ae322868b04a87&token=1082669959&lang=zh_CN&scene=21#wechat_redirect)
  {: id="20210330211654-42s2p97"}
- {: id="20210330211654-2dt1h8l"}[Raft协议实战之Redis Sentinel的选举Leader源码解析](http://weizijun.cn/2015/04/30/Raft%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98%E4%B9%8BRedis%20Sentinel%E7%9A%84%E9%80%89%E4%B8%BELeader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)
  {: id="20210330211654-ae23ic7"}
{: id="20210330211654-vdotqa5"}

目录：
{: id="20210330211654-xdtycnb"}

<!-- TOC -->

- {: id="20210330211654-ajlkr4v"}[Redis 集群以及应用](#redis-集群以及应用)
  {: id="20210330211654-flqj6n6"}
  - {: id="20210330211654-7cf9eef"}[集群](#集群)
    {: id="20210330211654-vduuqiw"}
    - {: id="20210330211654-p6p6cjw"}[主从复制](#主从复制)
      {: id="20210330211654-arfim8h"}
      - {: id="20210330211654-66uwkty"}[主从链(拓扑结构)](#主从链拓扑结构)
        {: id="20210330211654-v9a1o2n"}
      - {: id="20210330211654-mtaxsur"}[复制模式](#复制模式)
        {: id="20210330211654-ubnreag"}
      - {: id="20210330211654-pmumfrz"}[问题点](#问题点)
        {: id="20210330211654-0tjzo7b"}
      {: id="20210330211654-2z1jt0h"}
    - {: id="20210330211654-q1q70i0"}[哨兵机制](#哨兵机制)
      {: id="20210330211654-snq5tys"}
      - {: id="20210330211654-1lf7sll"}[拓扑图](#拓扑图)
        {: id="20210330211654-1mjhvmm"}
      - {: id="20210330211654-kd9y1tw"}[节点下线](#节点下线)
        {: id="20210330211654-meu6sqb"}
      - {: id="20210330211654-5s0twy0"}[Leader选举](#Leader选举)
        {: id="20210330211654-kv589an"}
      - {: id="20210330211654-ykfdpi0"}[故障转移](#故障转移)
        {: id="20210330211654-b6leqg0"}
      - {: id="20210330211654-xyqzsm5"}[读写分离](#读写分离)
        {: id="20210330211654-jwlrnj8"}
      - {: id="20210330211654-f0f7vhq"}[定时任务](#定时任务)
        {: id="20210330211654-2l5h7b4"}
      {: id="20210330211654-74fmy0a"}
    - {: id="20210330211654-lmr792w"}[分布式集群(Cluster)](#分布式集群cluster)
      {: id="20210330211654-bq8vyu2"}
      - {: id="20210330211654-6bz1mcv"}[拓扑图](#拓扑图)
        {: id="20210330211654-evr187i"}
      - {: id="20210330211654-sucbu37"}[通讯](#通讯)
        {: id="20210330211654-iu2btob"}
        - {: id="20210330211654-vuohzi7"}[集中式](#集中式)
          {: id="20210330211654-539ja2a"}
        - {: id="20210330211654-1s2nb4k"}[Gossip](#gossip)
          {: id="20210330211654-ynub1wr"}
        {: id="20210330211654-e8vb1ki"}
      - {: id="20210330211654-ii13r8q"}[寻址分片](#寻址分片)
        {: id="20210330211654-cbdoxwj"}
        - {: id="20210330211654-dkc95im"}[hash取模](#hash取模)
          {: id="20210330211654-q9jwuvb"}
        - {: id="20210330211654-novz27w"}[一致性hash](#一致性hash)
          {: id="20210330211654-gxznufv"}
        - {: id="20210330211654-rvf4581"}[hash槽](#hash槽)
          {: id="20210330211654-younk1z"}
        {: id="20210330211654-fumfaw4"}
      {: id="20210330211654-bf9a576"}
    {: id="20210330211654-a5x5aq5"}
  - {: id="20210330211654-bhaqpmx"}[使用场景](#使用场景)
    {: id="20210330211654-u945t9u"}
    - {: id="20210330211654-bwklnqd"}[热点数据](#热点数据)
      {: id="20210330211654-4m5ofi6"}
    - {: id="20210330211654-8zz5n7u"}[会话维持 Session](#会话维持-session)
      {: id="20210330211654-a2x68j9"}
    - {: id="20210330211654-36o7zjb"}[分布式锁 SETNX](#分布式锁-setnx)
      {: id="20210330211654-yhmc4fe"}
    - {: id="20210330211654-mydusuh"}[表缓存](#表缓存)
      {: id="20210330211654-49bveer"}
    - {: id="20210330211654-ppz2shu"}[消息队列 list](#消息队列-list)
      {: id="20210330211654-ka4cjes"}
    - {: id="20210330211654-lkkimjn"}[计数器 string](#计数器-string)
      {: id="20210330211654-t12kj4q"}
    {: id="20210330211654-9qkyy4b"}
  - {: id="20210330211654-wv11qq6"}[缓存设计](#缓存设计)
    {: id="20210330211654-53i0j41"}
    - {: id="20210330211654-p9m0vvm"}[更新策略](#更新策略)
      {: id="20210330211654-qe2v6ho"}
    - {: id="20210330211654-8vh31in"}[更新一致性](#更新一致性)
      {: id="20210330211654-q4psf14"}
    - {: id="20210330211654-ewk44eq"}[缓存粒度](#缓存粒度)
      {: id="20210330211654-9bblamg"}
    - {: id="20210330211654-qijzigc"}[缓存穿透](#缓存穿透)
      {: id="20210330211654-sb8r0qr"}
      - {: id="20210330211654-qqzl3zy"}[解决方案](#解决方案)
        {: id="20210330211654-gnrijg5"}
      {: id="20210330211654-075mfxb"}
    - {: id="20210330211654-aevqydh"}[缓存雪崩](#缓存雪崩)
      {: id="20210330211654-sawi0ye"}
      - {: id="20210330211654-colokxe"}[出现后应对](#出现后应对)
        {: id="20210330211654-c5kuhv2"}
      - {: id="20210330211654-vz6oz4c"}[请求过程](#请求过程)
        {: id="20210330211654-cw7jnmh"}
      {: id="20210330211654-dyek63s"}
    {: id="20210330211654-cdwsl7i"}
  {: id="20210330211654-6gx5sc7"}
{: id="20210330211654-fw3xdhh"}

<!-- /MarkdownTOC -->

# Redis 集群以及应用
{: id="20210330211654-lmw4jd9"}

## 集群
{: id="20210330211654-t7hed2s"}

### 主从复制
{: id="20210330211654-9b4sxz4"}

#### 主从链(拓扑结构)
{: id="20210330211654-6zekwi7"}

![主从](https://user-images.githubusercontent.com/26766909/67539461-d1a26c00-f714-11e9-81ae-61fa89faf156.png)
{: id="20210330211654-17a3yph"}

![主从](https://user-images.githubusercontent.com/26766909/67539485-e0891e80-f714-11e9-8980-d253239fcd8b.png)
{: id="20210330211654-ond6chw"}

#### 复制模式
{: id="20210330211654-5ntlu0n"}

- {: id="20210330211654-67ru6ap"}全量复制：Master 全部同步到 Slave
  {: id="20210330211654-mpurlxm"}
- {: id="20210330211654-pcirjnr"}部分复制：Slave 数据丢失进行备份
  {: id="20210330211654-o2urd5v"}
{: id="20210330211654-bthkh01"}

#### 问题点
{: id="20210330211654-7lftcgg"}

- {: id="20210330211654-q53turz"}同步故障
  {: id="20210330211654-jz5cp65"}
  - {: id="20210330211654-umie2p8"}复制数据延迟(不一致)
    {: id="20210330211654-h49isih"}
  - {: id="20210330211654-mfvzq80"}读取过期数据(Slave 不能删除数据)
    {: id="20210330211654-9lko6ga"}
  - {: id="20210330211654-401haed"}从节点故障
    {: id="20210330211654-b7fi1mv"}
  - {: id="20210330211654-vuevb24"}主节点故障
    {: id="20210330211654-9zyp1wy"}
  {: id="20210330211654-my1yuic"}
- {: id="20210330211654-5nb9don"}配置不一致
  {: id="20210330211654-od3v9m4"}
  - {: id="20210330211654-bo6clbv"}maxmemory 不一致:丢失数据
    {: id="20210330211654-jcl63tn"}
  - {: id="20210330211654-8ednkp5"}优化参数不一致:内存不一致.
    {: id="20210330211654-9ksjbd7"}
  {: id="20210330211654-hdfb57k"}
- {: id="20210330211654-xqh3rcd"}避免全量复制
  {: id="20210330211654-xtdddpg"}
  - {: id="20210330211654-qsbajwz"}选择小主节点(分片)、低峰期间操作.
    {: id="20210330211654-vdj5t7n"}
  - {: id="20210330211654-ys7ozbr"}如果节点运行 id 不匹配(如主节点重启、运行 id 发送变化)，此时要执行全量复制，应该配合哨兵和集群解决.
    {: id="20210330211654-d7s2e95"}
  - {: id="20210330211654-xch8mfu"}主从复制挤压缓冲区不足产生的问题(网络中断，部分复制无法满足)，可增大复制缓冲区( rel_backlog_size 参数).
    {: id="20210330211654-597ly84"}
  {: id="20210330211654-8gvgx8w"}
- {: id="20210330211654-h9sbw34"}复制风暴
  {: id="20210330211654-ngwngy6"}
{: id="20210330211654-vp046na"}

### 哨兵机制
{: id="20210330211654-yl7jsra"}

#### 拓扑图
{: id="20210330211654-jtr27z0"}

![哨兵机制-拓扑图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/哨兵机制-拓扑图.png)
{: id="20210330211654-jhv041w"}

#### 节点下线
{: id="20210330211654-gt99xfq"}

- {: id="20210330211654-zthpw8i"}主观下线
  {: id="20210330211654-u61mr7k"}
  - {: id="20210330211654-srxwwzs"}即 Sentinel 节点对 Redis 节点失败的偏见，超出超时时间认为 Master 已经宕机。
    {: id="20210330211654-0jkkdlh"}
  - {: id="20210330211654-5uhnrqt"}Sentinel 集群的每一个 Sentinel 节点会定时对 Redis 集群的所有节点发心跳包检测节点是否正常。如果一个节点在 `down-after-milliseconds` 时间内没有回复 Sentinel 节点的心跳包，则该 Redis 节点被该 Sentinel 节点主观下线。
    {: id="20210330211654-w3xxo9u"}
  {: id="20210330211654-yw6xhha"}
- {: id="20210330211654-izfjmpk"}客观下线
  {: id="20210330211654-59o151d"}
  - {: id="20210330211654-m7bk7d2"}所有 Sentinel 节点对 Redis 节点失败要达成共识，即超过 quorum 个统一。
    {: id="20210330211654-9yenwzc"}
  - {: id="20210330211654-9vkwf9p"}当节点被一个 Sentinel 节点记为主观下线时，并不意味着该节点肯定故障了，还需要 Sentinel 集群的其他 Sentinel 节点共同判断为主观下线才行。
    {: id="20210330211654-tsy30in"}
  - {: id="20210330211654-5jds0s0"}该 Sentinel 节点会询问其它 Sentinel 节点，如果 Sentinel 集群中超过 quorum 数量的 Sentinel 节点认为该 Redis 节点主观下线，则该 Redis 客观下线。
    {: id="20210330211654-x749s02"}
  {: id="20210330211654-t63w0j3"}
{: id="20210330211654-i449ura"}

#### Leader选举
{: id="20210330211654-r87ykac"}

- {: id="20210330211654-npxtqzp"}选举出一个 Sentinel 作为 Leader：集群中至少有三个 Sentinel 节点，但只有其中一个节点可完成故障转移.通过以下命令可以进行失败判定或领导者选举。
  {: id="20210330211654-pvrf51d"}
- {: id="20210330211654-51llmfp"}选举流程
  {: id="20210330211654-jkxlhr6"}
  1. {: id="20210330211654-bxwr35n"}每个主观下线的 Sentinel 节点向其他 Sentinel 节点发送命令，要求设置它为领导者.
     {: id="20210330211654-i0ew4bh"}
  2. {: id="20210330211654-remm8kl"}收到命令的 Sentinel 节点如果没有同意通过其他 Sentinel 节点发送的命令，则同意该请求，否则拒绝。
     {: id="20210330211654-9fzhdc7"}
  3. {: id="20210330211654-qn6kjpo"}如果该 Sentinel 节点发现自己的票数已经超过 Sentinel 集合半数且超过 quorum，则它成为领导者。
     {: id="20210330211654-gs15psl"}
  4. {: id="20210330211654-cqmrvb2"}如果此过程有多个 Sentinel 节点成为领导者，则等待一段时间再重新进行选举。
     {: id="20210330211654-g2j17xv"}
  {: id="20210330211654-1jwyzie"}
{: id="20210330211654-sh996bh"}

#### 故障转移
{: id="20210330211654-vx5di81"}

- {: id="20210330211654-dgahl3o"}转移流程
  {: id="20210330211654-sm28rq8"}
  1. {: id="20210330211654-eguacaq"}Sentinel 选出一个合适的 Slave 作为新的 Master(slaveof no one 命令)。
     {: id="20210330211654-at4itn0"}
  2. {: id="20210330211654-e2142yi"}向其余 Slave 发出通知，让它们成为新 Master 的 Slave( parallel-syncs 参数)。
     {: id="20210330211654-8f93yhz"}
  3. {: id="20210330211654-inpyr39"}等待旧 Master 复活，并使之称为新 Master 的 Slave。
     {: id="20210330211654-ml2shvp"}
  4. {: id="20210330211654-damadvu"}向客户端通知 Master 变化。
     {: id="20210330211654-qey66cy"}
  {: id="20210330211654-kty61y6"}
- {: id="20210330211654-zucwaru"}从 Slave 中选择新 Master 节点的规则(slave 升级成 master 之后)
  {: id="20210330211654-ltdxbox"}
  1. {: id="20210330211654-axbb9oa"}选择 slave-priority 最高的节点。
     {: id="20210330211654-iu50b7i"}
  2. {: id="20210330211654-b1l7wj7"}选择复制偏移量最大的节点(同步数据最多)。
     {: id="20210330211654-caz36ug"}
  3. {: id="20210330211654-x43qgcy"}选择 runId 最小的节点。
     {: id="20210330211654-8yzr3om"}
  {: id="20210330211654-8u9cs11"}
{: id="20210330211654-xixkk7y"}

> Sentinel 集群运行过程中故障转移完成，所有 Sentinel 又会恢复平等。Leader 仅仅是故障转移操作出现的角色。
> {: id="20210330211654-ums7zdi"}
{: id="20210330211654-mut4wv8"}

#### 读写分离
{: id="20210330211654-oame5z5"}

#### 定时任务
{: id="20210330211654-9h6ytq6"}

- {: id="20210330211654-mti0jv1"}每 1s 每个 Sentinel 对其他 Sentinel 和 Redis 执行 ping，进行心跳检测。
  {: id="20210330211654-ewg80ip"}
- {: id="20210330211654-ajqr25h"}每 2s 每个 Sentinel 通过 Master 的 Channel 交换信息(pub - sub)。
  {: id="20210330211654-3pojcje"}
- {: id="20210330211654-0vl36m9"}每 10s 每个 Sentinel 对 Master 和 Slave 执行 info，目的是发现 Slave 节点、确定主从关系。
  {: id="20210330211654-b6eeflq"}
{: id="20210330211654-tifcp9c"}

### 分布式集群(Cluster)
{: id="20210330211654-c8669hk"}

#### 拓扑图
{: id="20210330211654-8eg2gg1"}

![image](https://user-images.githubusercontent.com/26766909/67539510-f8f93900-f714-11e9-9d8d-08afdecff95a.png)
{: id="20210330211654-9uavtgq"}

#### 通讯
{: id="20210330211654-5t78gbe"}

##### 集中式
{: id="20210330211654-ssfzdxy"}

> 将集群元数据(节点信息、故障等等)几种存储在某个节点上。
> {: id="20210330211654-px0fryt"}
{: id="20210330211654-17f3vfx"}

- {: id="20210330211654-debg4vk"}优势
  {: id="20210330211654-b5u6q7f"}
  1. {: id="20210330211654-4cuy2ww"}元数据的更新读取具有很强的时效性，元数据修改立即更新
     {: id="20210330211654-a5jg19x"}
  {: id="20210330211654-n0c2lx6"}
- {: id="20210330211654-9wzpjd2"}劣势
  {: id="20210330211654-r3y3952"}
  1. {: id="20210330211654-jrn7blt"}数据集中存储
     {: id="20210330211654-bjkkr1g"}
  {: id="20210330211654-3uufzti"}
{: id="20210330211654-ujev7h5"}

##### Gossip
{: id="20210330211654-g979rm9"}

![image](https://user-images.githubusercontent.com/26766909/67539546-16c69e00-f715-11e9-9891-1e81b6af624c.png)
{: id="20210330211654-wpo0db5"}

- {: id="20210330211654-j3nxksk"}[Gossip 协议](https://www.jianshu.com/p/8279d6fd65bb)
  {: id="20210330211654-rl77it1"}
{: id="20210330211654-ow4eosm"}

#### 寻址分片
{: id="20210330211654-fnslfzz"}

##### hash取模
{: id="20210330211654-ermz8mr"}

- {: id="20210330211654-n6lmb43"}hash(key)%机器数量
  {: id="20210330211654-4kjxe0q"}
- {: id="20210330211654-iku3r73"}问题
  {: id="20210330211654-y4r9kgw"}
  1. {: id="20210330211654-ai6bval"}机器宕机，造成数据丢失，数据读取失败
     {: id="20210330211654-n2532sg"}
  2. {: id="20210330211654-plch0mm"}伸缩性
     {: id="20210330211654-vygccyu"}
  {: id="20210330211654-9xlrqvs"}
{: id="20210330211654-wylft1m"}

##### 一致性hash
{: id="20210330211654-r4qasdm"}

- {: id="20210330211654-33fe2mw"}![image](https://user-images.githubusercontent.com/26766909/67539595-352c9980-f715-11e9-8e4a-9d9c04027785.png)
  {: id="20210330211654-pz6ptfs"}
- {: id="20210330211654-hdzbzz2"}问题
  {: id="20210330211654-rzhrtus"}
  1. {: id="20210330211654-pfh73gz"}一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。
     {: id="20210330211654-sikgxvx"}
     - {: id="20210330211654-782es6b"}解决方案
       {: id="20210330211654-hvl7g6o"}
       - {: id="20210330211654-hy8rbru"}可以通过引入虚拟节点机制解决：即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。
         {: id="20210330211654-lvov393"}
       {: id="20210330211654-ei1wjfp"}
     {: id="20210330211654-yi0tn82"}
  {: id="20210330211654-ztwyj5k"}
{: id="20210330211654-4w4poep"}

##### hash槽
{: id="20210330211654-dlybe6o"}

- {: id="20210330211654-jrz0moi"}CRC16(key)%16384
  {: id="20210330211654-wchs179"}
- {: id="20210330211654-135km1h"}
{: id="20210330211654-n97fji0"}

![image](https://user-images.githubusercontent.com/26766909/67539610-3fe72e80-f715-11e9-8e0d-ea58bc965795.png)
{: id="20210330211654-7n1ibc0"}

## 使用场景
{: id="20210330211654-7leu3ax"}

### 热点数据
{: id="20210330211654-7news0q"}

存取数据优先从 Redis 操作，如果不存在再从文件（例如 MySQL）中操作，从文件操作完后将数据存储到 Redis 中并返回。同时有个定时任务后台定时扫描 Redis 的 key，根据业务规则进行淘汰，防止某些只访问一两次的数据一直存在 Redis 中。
{: id="20210330211654-5hdwtni"}

> 例如使用 Zset 数据结构，存储 Key 的访问次数/最后访问时间作为 Score，最后做排序，来淘汰那些最少访问的 Key。
> {: id="20210330211654-q3u7uks"}
{: id="20210330211654-i0d9lol"}

如果企业级应用，可以参考：[阿里云的 Redis 混合存储版][1]
{: id="20210330211654-aj214pf"}

### 会话维持 Session
{: id="20210330211654-l4vor7b"}

会话维持 Session 场景，即使用 Redis 作为分布式场景下的登录中心存储应用。每次不同的服务在登录的时候，都会去统一的 Redis 去验证 Session 是否正确。但是在微服务场景，一般会考虑 Redis + JWT 做 Oauth2 模块。
{: id="20210330211654-ettfv28"}

> 其中 Redis 存储 JWT 的相关信息主要是留出口子，方便以后做统一的防刷接口，或者做登录设备限制等。
> {: id="20210330211654-iu1eh7c"}
{: id="20210330211654-mt741g7"}

### 分布式锁 SETNX
{: id="20210330211654-7y8vk5h"}

命令格式：`SETNX key value`：当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。
{: id="20210330211654-6bfrbkc"}

1. {: id="20210330211654-rxwbidx"}超时时间设置：获取锁的同时，启动守护线程，使用 expire 进行定时更新超时时间。如果该业务机器宕机，守护线程也挂掉，这样也会自动过期。如果该业务不是宕机，而是真的需要这么久的操作时间，那么增加超时时间在业务上也是可以接受的，但是肯定有个最大的阈值。
   {: id="20210330211654-hjrqvu3"}
2. {: id="20210330211654-id9djjs"}但是为了增加高可用，需要使用多台 Redis，就增加了复杂性，就可以参考 Redlock：[Redlock分布式锁](Redlock分布式锁.md#怎么在单节点上实现分布式锁)
   {: id="20210330211654-t5bm2v0"}
{: id="20210330211654-qveykle"}

### 表缓存
{: id="20210330211654-216dabg"}

Redis 缓存表的场景有黑名单、禁言表等。访问频率较高，即读高。根据业务需求，可以使用后台定时任务定时刷新 Redis 的缓存表数据。
{: id="20210330211654-csi2yym"}

### 消息队列 list
{: id="20210330211654-tryhvid"}

主要使用了 List 数据结构。
List 支持在头部和尾部操作，因此可以实现简单的消息队列。
{: id="20210330211654-ujgnxqc"}

1. {: id="20210330211654-fsl3vba"}发消息：在 List 尾部塞入数据。
   {: id="20210330211654-0tgx5om"}
2. {: id="20210330211654-kq30djy"}消费消息：在 List 头部拿出数据。
   {: id="20210330211654-ujfsdvy"}
{: id="20210330211654-rwqfa7f"}

同时可以使用多个 List，来实现多个队列，根据不同的业务消息，塞入不同的 List，来增加吞吐量。
{: id="20210330211654-sqp6gey"}

### 计数器 string
{: id="20210330211654-mucb3lm"}

主要使用了 INCR、DECR、INCRBY、DECRBY 方法。
{: id="20210330211654-hv3dtfq"}

INCR key：给 key 的 value 值增加一
DECR key：给 key 的 value 值减去一
{: id="20210330211654-fzd3vhd"}

## 缓存设计
{: id="20210330211654-cawnxdk"}

### 更新策略
{: id="20210330211654-0yynskr"}

- {: id="20210330211654-7myk6rt"}LRU、LFU、FIFO 算法自动清除：一致性最差，维护成本低。
  {: id="20210330211654-2rka4a3"}
- {: id="20210330211654-lzbry3e"}超时自动清除(key expire)：一致性较差，维护成本低。
  {: id="20210330211654-yb41dkd"}
- {: id="20210330211654-w2o5qm8"}主动更新：代码层面控制生命周期，一致性最好，维护成本高。
  {: id="20210330211654-pu99bmt"}
{: id="20210330211654-nq3nglj"}

在 Redis 根据在 redis.conf 的参数 `maxmemory` 来做更新淘汰策略：
{: id="20210330211654-ivef769"}

1. {: id="20210330211654-doykgx2"}noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL 命令)。
   {: id="20210330211654-c4hj5e9"}
2. {: id="20210330211654-fuzm5oo"}allkeys-lru: 所有 key 通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
   {: id="20210330211654-i09tsk0"}
3. {: id="20210330211654-vsnl8jq"}volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
   {: id="20210330211654-lmedomy"}
4. {: id="20210330211654-uzvs6v1"}allkeys-random: 所有key通用; 随机删除一部分 key。
   {: id="20210330211654-qlfeedi"}
5. {: id="20210330211654-ldnv9ch"}volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
   {: id="20210330211654-rx33qcs"}
6. {: id="20210330211654-bdkj21i"}volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。
   {: id="20210330211654-qj3xcoe"}
{: id="20210330211654-4y6aq8n"}

### 更新一致性
{: id="20210330211654-0sqlozx"}

- {: id="20210330211654-vfgd4f5"}读请求：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
  {: id="20210330211654-339949n"}
- {: id="20210330211654-szjvbif"}写请求：先删除缓存，然后再更新数据库(避免大量地写、却又不经常读的数据导致缓存频繁更新)。
  {: id="20210330211654-d10f9uo"}
{: id="20210330211654-16wsq66"}

### 缓存粒度
{: id="20210330211654-p95r86r"}

- {: id="20210330211654-j5z8x56"}通用性：全量属性更好。
  {: id="20210330211654-r683m1d"}
- {: id="20210330211654-5bgkqge"}占用空间：部分属性更好。
  {: id="20210330211654-9mtr9g7"}
- {: id="20210330211654-f14s3en"}代码维护成本。
  {: id="20210330211654-yfk1yiw"}
{: id="20210330211654-qogf89a"}

### 缓存穿透
{: id="20210330211654-4wvx53f"}

> 当大量的请求无命中缓存、直接请求到后端数据库(业务代码的 bug、或恶意攻击)，同时后端数据库也没有查询到相应的记录、无法添加缓存。
> 这种状态会一直维持，流量一直打到存储层上，无法利用缓存、还会给存储层带来巨大压力。
> {: id="20210330211654-w5f3o01"}
{: id="20210330211654-rgyfzra"}

#### 解决方案
{: id="20210330211654-7opuvvt"}

1. {: id="20210330211654-3c1d138"}请求无法命中缓存、同时数据库记录为空时在缓存添加该 key 的空对象(设置过期时间)，缺点是可能会在缓存中添加大量的空值键(比如遭到恶意攻击或爬虫)，而且缓存层和存储层数据短期内不一致；
   {: id="20210330211654-3xnag47"}
2. {: id="20210330211654-np2qy04"}使用布隆过滤器在缓存层前拦截非法请求、自动为空值添加黑名单(同时可能要为误判的记录添加白名单).但需要考虑布隆过滤器的维护(离线生成/ 实时生成)。
   {: id="20210330211654-f1tquyy"}
{: id="20210330211654-droadwv"}

### 缓存雪崩
{: id="20210330211654-je6wigm"}

> 缓存崩溃时请求会直接落到数据库上，很可能由于无法承受大量的并发请求而崩溃，此时如果只重启数据库，或因为缓存重启后没有数据，新的流量进来很快又会把数据库击倒。
> {: id="20210330211654-shweypp"}
{: id="20210330211654-itgi60x"}

#### 出现后应对
{: id="20210330211654-r3eobbm"}

- {: id="20210330211654-4661zao"}事前：Redis 高可用，主从 + 哨兵，Redis Cluster，避免全盘崩溃。
  {: id="20210330211654-ngsns91"}
- {: id="20210330211654-e7snnx6"}事中：本地 ehcache 缓存 + hystrix 限流 & 降级，避免数据库承受太多压力。
  {: id="20210330211654-xeq9gid"}
- {: id="20210330211654-new1lkh"}事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
  {: id="20210330211654-e8cwlkk"}
{: id="20210330211654-8yw4txe"}

#### 请求过程
{: id="20210330211654-xrzs11v"}

1. {: id="20210330211654-t1moi0v"}用户请求先访问本地缓存，无命中后再访问 Redis，如果本地缓存和 Redis 都没有再查数据库，并把数据添加到本地缓存和 Redis；
   {: id="20210330211654-b3ifkf2"}
2. {: id="20210330211654-s5mmf1i"}由于设置了限流，一段时间范围内超出的请求走降级处理(返回默认值，或给出友情提示)。
   {: id="20210330211654-ct7tcae"}
{: id="20210330211654-4gvgf0p"}


{: id="20210330211654-91hc8hh" type="doc"}
