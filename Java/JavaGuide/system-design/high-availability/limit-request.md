### 限流的算法有哪些？
{: id="20210330211656-qnccox9"}

简单介绍 4 种非常好理解并且容易实现的限流算法！
{: id="20210330211656-ydlj8vl"}

下图的图片不是 Guide 哥自己画的哦！图片来源于 InfoQ 的一篇文章[《分布式服务限流实战，已经为你排好坑了》](https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673)。
{: id="20210330211656-o7gwwao"}

#### 固定窗口计数器算法
{: id="20210330211656-eo5bznz"}

该算法规定我们单位时间处理的请求数量。比如我们规定我们的一个接口一分钟只能访问10次的话。使用固定窗口计数器算法的话可以这样实现：给定一个变量counter来记录处理的请求数量，当1分钟之内处理一个请求之后counter+1，1分钟之内的如果counter=100的话，后续的请求就会被全部拒绝。等到 1分钟结束后，将counter回归成0，重新开始计数（ps：只要过了一个周期就讲counter回归成0）。
{: id="20210330211656-yiaeme5"}

这种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如我们限制一个接口一分钟只能访问10次的话，前半分钟一个请求没有接收，后半分钟接收了10个请求。
{: id="20210330211656-r5s39bm"}

![固定窗口计数器算法](https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png)
{: id="20210330211656-r0c1it3"}

#### 滑动窗口计数器算法
{: id="20210330211656-xrhe0v1"}

该算法算的上是固定窗口计数器算法的升级版。滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的接口限流每分钟处理60个请求，我们可以把 1 分钟分为60个窗口。每隔1秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。
{: id="20210330211656-nfaw24g"}

很显然：当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。
{: id="20210330211656-k1zfbem"}

![滑动窗口计数器算法](https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png)
{: id="20210330211656-8ycfjtn"}

#### 漏桶算法
{: id="20210330211656-8oidgv2"}

我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了。
{: id="20210330211656-o35oamc"}

![漏桶算法](https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png)
{: id="20210330211656-m5l9e73"}

#### 令牌桶算法
{: id="20210330211656-ckk7p6n"}

令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。
{: id="20210330211656-rg8s4x9"}

![令牌桶算法](https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png)
{: id="20210330211656-7ks40gh"}

###
{: id="20210330211656-3dd771u"}


{: id="20210330211656-8qdgz2c" type="doc"}
