- {: id="20210307230335-ovclt9w" fold="0"}类与对象
  {: id="20210307230335-rk2yjz3" updated="20210307230349"}

  - {: id="20210307230349-mdqngwp" fold="0"}用类制造对象
    {: id="20210307230349-hpqiw60" updated="20210307230357"}
  - {: id="20210307230357-zm3ey0g"}定义类
    {: id="20210307230357-11uww89" updated="20210307230400"}
  - {: id="20210307230400-4787byt"}成员变量和成员函数
    {: id="20210307230400-i06mf2v" updated="20210307230408"}

    - {: id="20210307230409-edzgciz"}`this`的用法
      {: id="20210307230409-a3rw8ly" updated="20210309225914"}
    - {: id="20210307230418-flymr8l"}成员函数可以直接互相调用
      {: id="20210307230418-wl22xj7" updated="20210313211854"}
    - {: id="20210307230434-as163a5"}成员变量的生存期是对象的生存期
      {: id="20210307230434-ilmfhwz" updated="20210307230454"}
    - {: id="20210307230454-g4hxeaj"}本地变量的生存期是函数的生存期
      {: id="20210307230454-jopza0m" updated="20210307230511"}
    {: id="20210307230514-i53t4pt"}
  - {: id="20210307230511-02k0nkd"}对象初始化
    {: id="20210307230511-2yj7y8l" updated="20210307230524"}

    - {: id="20210307230525-5q1agn4"}构造函数
      {: id="20210307230525-6v9e4hd" updated="20210307231031"}

      - {: id="20210307231123-h1ixcyn"}会先运行类本身定义的初始化，再运行函数体内的代码
        {: id="20210307231123-vh09xct" updated="20210307231123"}
      - {: id="20210307231140-4n6c0xk"}重载
        {: id="20210307231140-p5n6uvi" updated="20210307231142"}
      - {: id="20210307231238-vivk1t5"}可以用`this()`调用其他的构造函数
        {: id="20210307231238-ycaeup9" updated="20210307231332"}
      {: id="20210307234439-ykq8ac0"}
    {: id="20210307234439-8c6qxg0"}
  {: id="20210307234440-pqxhf2z"}
- {: id="20210308152711-ntp89ye"}对象交互
  {: id="20210307234438-c2zihi9" updated="20210307234443"}

  - {: id="20210307234438-nmtkvdu"}类之间的交互
    {: id="20210308152711-ey2mwys" updated="20210308152716"}

    - {: id="20210307234443-lwvorf1"}类与类之间尽量解耦
      {: id="20210307234443-g68jlvo" updated="20210307234501"}
    - {: id="20210308094807-is82y7a"}对象=属性+服务
      {: id="20210308094807-ixmzoay" updated="20210308094818"}

      - {: id="20210308094826-f7y1xby"}数据：属性或状态
        {: id="20210308094826-9uw5rei" updated="20210308094834"}
      - {: id="20210308094835-2jyu723"}操作：函数
        {: id="20210308094835-tq1jt6o" updated="20210308094844"}
      - {: id="20210308094845-pvioz5s"}把数据和对数据的操作放在一起`->`封装
        {: id="20210308094845-3sn6wew" updated="20210308094912"}
      {: id="20210308141058-w9s4y3b"}
    - {: id="20210308155801-hpldpwu"}成员变量的私有是针对类而非对象
      {: id="20210308135812-bsf9b2f" updated="20210308135844"}

      - {: id="20210308135812-su7j8v7"}即使在其他类中新建了该类的对象，依然无法访问该类中private修饰的成员
        {: id="20210308155801-mc6etdp"}

        - {: id="20210308140227-tu3yzcp"}没有加上关键字的成员函数默认为`friendly`
          {: id="20210308140227-y8mzcaw" updated="20210308140332"}

          - {: id="20210308140332-mk8plt0"}即位于同一个包中的类可以访问
            {: id="20210308140332-1eiipj9" updated="20210308140332"}
          {: id="20210308140902-dxh9r9b"}
        {: id="20210308155808-hqjm3vc"}
      {: id="20210308141519-mx3y6v8"}
    - {: id="20210308140901-x67jf58"}带有`public`关键字的类名称必须与所在的`.java`文件名相同
      {: id="20210308140901-knbs5t8" updated="20210308141003"}

      - {: id="20210308141050-n3865gd"}`compilation`编译单元指的是一个`.java`文件
        {: id="20210308141058-95erpkw" updated="20210308141229"}

        - {: id="20210308141231-h6k7dh0"}即一次对一个编译单元做编译的动作
          {: id="20210308141231-mkaf3zi" updated="20210308141418"}
        - {: id="20210308141430-29mruj7"}一个编译单元中可以有多个类，但只能有一个类带有`public`关键字
          {: id="20210308141430-5eqeqo4" updated="20210308141510"}
        {: id="20210308141548-7zbkjy9"}
      {: id="20210308141548-8bkgwmb"}
    {: id="20210308152711-rnhou7e"}
  - {: id="20210308141547-7m7ze4l"}包
    {: id="20210308141547-jlgel9c" updated="20210308141551"}

    - {: id="20210308142402-8myt31d"}不同包之间的类交互时需要使用`import`
      {: id="20210308142402-11xzpu6" updated="20210308142434"}
    {: id="20210308152719-te2lebc"}
  - {: id="20210308144821-7kzuqiz"}类变量
    {: id="20210308144821-0m6wcf3" updated="20210308144828"}

    - {: id="20210308152029-f8rdbml"}带有`static`关键字的成员变量称为类变量
      {: id="20210308152029-u449ncs" updated="20210308152053"}

      - {: id="20210308152053-554e8r4"}类变量是属于类的变量，和对象没关系
        {: id="20210308152053-2yto9rd" updated="20210308152244"}
      {: id="20210308152404-2fvz1hj"}
    - {: id="20210308152319-r3o6tq3"}带有`static`关键字的成员函数称为类函数
      {: id="20210308152319-jdpbc0z" updated="20210308152410"}

      - {: id="20210308152410-k96ii00"}类函数只能访问类变量
        {: id="20210308152410-7i2g691" updated="20210308152413"}
      {: id="20210308152553-7y0lwo0"}
    - {: id="20210308152552-tz40s81"}类变量只会在类装载时初始化，和对象没有关系
      {: id="20210308152552-jy96cun" updated="20210308152633"}
    - {: id="20210308155610-hguhgdo"}类函数由于不属于任何对象，因此也没有办法建立与调用它们的对象的关系，在其中并不能使用super，this这些用于实例的关键字
      {: id="20210308155610-9jjpp9p"}
    {: id="20210308152722-vfcyxau"}
  {: id="20210308152658-gbrnbv6"}
- {: id="20210308152719-5z7jqfo"}对象容器
  {: id="20210308152722-txrvatu" updated="20210308152732"}

  - {: id="20210308152732-5q8vshq"}顺序容器
    {: id="20210308152732-sbvyjjn" updated="20210308152735"}

    - {: id="20210308153454-pxeeoco"}`ArrayList<ElemType>`范型类，是一种容器
      {: id="20210308153454-4hwbz48" updated="20210308160234"}

      - {: id="20210308160118-juf2pvt"}`add(ElemType)`
        {: id="20210308160118-thkaw0c" updated="20210308160154"}

        - {: id="20210308160130-k335php"}`add(index,ElemType)`
          {: id="20210308160130-ee3v0b2" updated="20210308160249"}
        {: id="20210308160253-812a5jo"}
      - {: id="20210308160252-ru039tw"}`get(index)`
        {: id="20210308160252-g49e959" updated="20210308160306"}
      - {: id="20210308160315-v3dgmhs"}`remove(index)`
        {: id="20210308160315-fg5on7x" updated="20210308160327"}
      - {: id="20210308160340-ldv9sao"}`size()`
        {: id="20210308160340-y0lcjyt" updated="20210308160344"}
      - {: id="20210308161442-rmr8y44"}`toArray(ElemType[])`
        {: id="20210308161442-rml7gvi" updated="20210308161513"}
      {: id="20210308161651-zujaw3v"}
    - {: id="20210308161643-il4fxwu"}把对象放进容器中时，放进去的是对象的地址
      {: id="20210308161643-34s50g1" updated="20210312224813"}
    - {: id="20210308153616-is0yzn8"}容器类型
      {: id="20210308153616-ytgp2dp" updated="20210308153624"}
    - {: id="20210308153624-fr2ml33"}元素类型
      {: id="20210308153624-dhdb9hw" updated="20210308153628"}
    {: id="20210308162638-mdq8z1u"}
  - {: id="20210308162637-z173xhy"}对象数组
    {: id="20210308162637-9avzzw6" updated="20210308162644"}

    - {: id="20210308162645-imvmzc3"}对象数组中的元素存储的是对象的地址
      {: id="20210308162645-wcf3bnz" updated="20210308162704"}
    - {: id="20210308162721-c5s666z"}`foreach`语法中、或者函数参数传递时，如果有对象相关的操作会生效，与基本数据类型数组不同
      {: id="20210308162721-12wprnm" updated="20210312224902"}
    {: id="20210308171054-vlkrhxm"}
  - {: id="20210308171053-wfj2wby"}集合容器（Set）
    {: id="20210308171053-6c9k50h" updated="20210308171557"}

    - {: id="20210308171510-sdgvaaf"}元素不能重复
      {: id="20210308171510-93lsag2" updated="20210308171515"}
    - {: id="20210308171713-l7w1hks"}元素是无序的，因此无法通过
      {: id="20210308171713-3rbu8c4" updated="20210308171726"}
    - {: id="20210308171555-bm8mwd3"}类的`toString()`方法可以输出整个对象的内容
      {: id="20210308171557-xfs8dan" updated="20210308171647"}
    {: id="20210308171649-8qb7bm4"}
  - {: id="20210308171648-4fqmw1y"}散列表（Hash）
    {: id="20210308171648-mbaej3b" updated="20210308172214"}

    - {: id="20210308172215-3m6ncm7"}`HashMap<key,value>`（哈希表）
      {: id="20210308172215-a33yg3c" updated="20210308173207"}

      - {: id="20210308173117-1snsj4n"}`put(key,value)`
        {: id="20210308173117-xufc96y" updated="20210308173218"}
      - {: id="20210308173219-whu9jph"}`get(key)`
        {: id="20210308173219-o5k5oj1" updated="20210308173238"}
      - {: id="20210308173411-zlcwn9e"}`keySet()`
        {: id="20210308173411-z8rdbvi" updated="20210308173419"}

        - {: id="20210308173420-wx6a2c6"}`size()`
          {: id="20210308173420-8lgrs1e" updated="20210308173427"}
        - {: id="20210308173519-agkg3vi"}用于遍历
          {: id="20210308173519-rmzk007" updated="20210308173523"}
        {: id="20210308173421-xofzuof"}
      - {: id="20210308173320-eiqxibe"}一个键只能对应最后一次存入的值
        {: id="20210308173320-f6jq3ll" updated="20210308173335"}
      {: id="20210308200249-3t2eie3"}
    {: id="20210308200249-hoofbr3"}
  {: id="20210308200250-wekyc3t"}
- {: id="20210308200247-v49x8w9"}继承与多态
  {: id="20210308200247-5ii3wfz" updated="20210308200302"}

  - {: id="20210308200302-cd114i1"}继承
    {: id="20210308200302-0c4anev" updated="20210308220513"}

    - {: id="20210308220516-uekdcb5"}| **父类成员访问属性** | **在父类中的含义**                 | **在子类中的含义**                                                                |
      | ---------------------- | ------------------------------------ | ----------------------------------------------------------------------------------- |
      | public               | 对所有人开放                       | 对所有人开放                                                                      |
      | protected            | 只有包内其他类、自己和子类可以访问 | 只有包内其他类、自己和子类可以访问                                                |
      | 缺省                 | 只有包内其他类可以访问             | 如果子类与父类在同一个包内，只有包内其它类可以访问；否则，相当于private，不能访问 |
      | private              | 只有自己可以访问                   | 不能访问                                                                          |
      {: id="20210308220516-uw0xqsg" updated="20210308221700"}
    - {: id="20210310104312-pec20en"}我们不可以在子类中重新定义继承得到的成员的访问属性
      {: id="20210310104312-0psyl79" updated="20210310104824"}
    - {: id="20210313212741-pum9cr8"}如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。
      {: id="20210313212741-7utedy5" updated="20210313212741"}
    - {: id="20210310104824-6k3vttn"}在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。
      {: id="20210310104824-g78otaf"}
    - {: id="20210310110537-yglvv5n"}当子类构造器没有`super()`时，会自动去找父类那个没有参数的构造器
      {: id="20210310110537-rgv3dgv" updated="20210310110629"}
    - {: id="20210310110703-076lqgo"}`super()`在一个构造器中只能调用一次，且必须在第一行
      {: id="20210310110703-gl7sxcq" updated="20210310110733"}
    - {: id="20210310111403-v0bgayz"}虽然子类通过继承得到了父类的所有成员，但是其使用仍受到访问属性的限制。对于父类中private修饰的内容，子类虽得到但不能访问。
      {: id="20210310111403-31v7ro1"}
    {: id="20210310111429-r5xlr02"}
  - {: id="20210310111429-8sceyk4"}多态变量和向上造型
    {: id="20210310111429-pd4dj4y" updated="20210310111447"}

    - {: id="20210310111651-xec17xs"}类定义了类型，类可以有子类，所以由那些类定义的类型可以有子类型。子类型类似于类的层次,类型也构成了类型层次。子类所定义的类型是其超类的类型的子类型。
      {: id="20210310111651-z28d6kz" updated="20210310111715"}
    - {: id="20210310111818-pwoers8"}**一个变量可以保存其所声明的类型或该类型的任何子类型。**
      {: id="20210310111818-9lq6n6j"}

      - {: id="20210310111855-rp3ics8"}对象变量可以保存其声明的类型的对象，或该类型的任何子类型的对象
        {: id="20210310111855-edn2tqc" updated="20210310111902"}
      - {: id="20210310111942-rqofwj5"}Java中保存对象类型的变量是多态变量。“多态”这个术语(字面意思是许多形态)是指一个变量可以保存不同类型(即其声明的类型或任何子类型)的对象。
        {: id="20210310111942-vf1it2x"}
      - {: id="20210310112056-qdy481g"}子类的对象可以被当作父类的对象来使用
        {: id="20210310112056-bjz16sx" updated="20210310112110"}

        - {: id="20210310112111-6s96my7"}赋值给父类的变量
          {: id="20210310112111-m7w97ot" updated="20210310112118"}
        - {: id="20210310112118-7bqjlwo"}传递给需要父类对象的函数
          {: id="20210310112118-o8ge6vr" updated="20210310112128"}
        - {: id="20210310112128-241lxrg"}放进存放父类对象的容器里
          {: id="20210310112128-pv22rnt" updated="20210310112139"}
        {: id="20210310112517-uml7vzc"}
      - {: id="20210310112508-m69s8ws" updated="20210310112633"}多态变量
        {: id="20210310112638-g6eg37i" updated="20210310112642"}

        - {: id="20210310112638-cz76qd3"}Java的对象变是多态的，她们能保存不止一种类型的对象
          {: id="20210310112638-7ll27gv" updated="20210310112638"}
        - {: id="20210310112642-5jf7if3"}它们可以保存的是声明类型的对象，或声明类型的子类的对象
          {: id="20210310112643-9irf405" updated="20210310112716"}
        - {: id="20210310112839-b6jtxm2"}当把子类的对象赋给父类的变量的时候，就发生了向上造型
          {: id="20210310112839-re9ihqu" updated="20210310113001"}
        {: id="20210310112857-d86qbug"}
      - {: id="20210310112959-6ropaqv"}造型（Cast）
        {: id="20210310113001-dms0stg" updated="20210310230035"}

        - {: id="20210310114110-dmnu4eb"}子类的对象可以赋值给父类的变量
          {: id="20210310114110-m5xs3vk" updated="20210310114123"}

          - {: id="20210310114124-scdifbt"}**Java中不存在对象对对象的赋值，只是让两个对象的管理者管理同一个对象**
            {: id="20210310114124-nmjta4g" updated="20210310114419"}
          {: id="20210310114216-u8onfn7"}
        - {: id="20210310114147-uoz82c4"}父类的对象不能赋值给子类的变量
          {: id="20210310114147-kg35iqx" updated="20210310114223"}

          - {: id="20210310114226-x3r53b7"}可以用造型（只有当父类变量实际管理的是子类变量才行）
            {: id="20210310114226-qo8afvr" updated="20210310114257"}
          {: id="20210310225332-5if3bgf"}
        - {: id="20210310225319-fdgeg0r"}对象本身并没有发生任何变化
          {: id="20210310225319-6k7jyo2" updated="20210310225345"}

          - {: id="20210310225347-vy9u581"}所以不是“类型转换”
            {: id="20210310225347-8gkb411" updated="20210310225420"}
          {: id="20210310225837-r1d89d1"}
        - {: id="20210310225836-gjcyfxi"}运行时有机制来检查这样的转化是否合理
          {: id="20210310225837-e6uq9fs" updated="20210310225853"}

          - {: id="20210310225853-oatgk2r"}`ClassCastException`
            {: id="20210310225853-4yrmflx" updated="20210310225916"}
          {: id="20210310230104-m3bdtgn"}
        - {: id="20210310230103-saryvt6"}向上造型
          {: id="20210310230103-rv5ygy1" updated="20210310230108"}

          - {: id="20210310230109-jjar7il"}拿一个子类的对象，当作弗雷德对象来用
            {: id="20210310230109-56v3mlv" updated="20210310230125"}
          - {: id="20210310230123-bns42lv"}向上造型是默认的，不需要运算符
            {: id="20210310230125-z2tn25g"}
          - {: id="20210310230211-1j1j20g"}向上造型总是安全的
            {: id="20210310230211-aygdb6x" updated="20210310230211"}
          {: id="20210310230547-fir30bt"}
        {: id="20210310230548-zpptsef"}
      {: id="20210310230548-fxwq536"}
    {: id="20210310230549-gvvs59y"}
  - {: id="20210310230546-u2epk43"}多态
    {: id="20210310230546-r8i8kgy" updated="20210310230556"}

    - {: id="20210310230710-e3ddbb9"}如果子类的方法覆盖了父类的方法，我们也说父类的那个方法在子类有了新的版本或者新的实现。覆盖的新版本具有与老版本相同的方法签名：相同的方法名称和参数表。因此，对于外界来说，子类并没有增加新的方法，仍然是在父类中定义过的那个方法。不同的是，这是一个新版本，所以通过子类的对象调用这个方法，执行的是子类自己的方法。
      {: id="20210310230657-swxiax3" updated="20210310230710"}
    - {: id="20210310230557-3poontp"}覆盖关系并不说明父类中的方法已经不存在了，而是当通过一个子类的对象调用这个方法时，子类中的方法取代了父类的方法，父类的这个方法被“覆盖”起来而看不见了。而当通过父类的对象调用这个方法时，实际上执行的仍然是父类中的这个方法。注意我们这里说的是对象而不是变量，因为一个类型为父类的变量有可能实际指向的是一个子类的对象。
      {: id="20210310230710-yzvh8zx" updated="20210310230715"}
    - {: id="20210310230715-qu6dmbo"}当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。绑定表明了调用一个方法的时候，我们使用的是哪个方法。绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了；另一种是晚绑定，即动态绑定。动态绑定在运行的时候根据变量当时实际所指的对象的类型动态决定调用的方法。Java缺省使用动态绑定。
      {: id="20210310230715-qqu0dys" updated="20210310230715"}
    - {: id="20210310231021-m6akyih"}函数调用的绑定
      {: id="20210310231142-ohdjlsy" updated="20210310231154"}

      - {: id="20210310231142-pi3jrdo"}当通过对象变量调用函数的时候，调用哪个函数这件事情叫做绑定
        {: id="20210310231142-au2gavn" updated="20210310231142"}
      - {: id="20210310231038-noxp8an"}静态绑定：根据变量的声明类型来决定
        {: id="20210310231038-cvenv3t" updated="20210310231038"}
      - {: id="20210310231041-dx0zz1u"}动态绑定：根据变量的动态类型来决定
        {: id="20210310231041-y32e8us" updated="20210310231041"}
      - {: id="20210310231046-a4dut6u"}在成员函数中调用其他成员函数也是通过this这个对象变量来调用的
        {: id="20210310231046-807z2ob" updated="20210310231052"}
      {: id="20210310231217-vb2e901"}
    - {: id="20210310231201-92ljkqk"}覆盖 override
      {: id="20210310231201-n9iqxad"}

      - {: id="20210310231220-r7ptqsh"}子类和父类中存在名称和参数表完全相同函数，这一对函数构成覆盖关系
        {: id="20210310231220-9dhoib4" updated="20210310231220"}
      - {: id="20210310231224-fbwxnbj"}通过父类的变量调用存在覆盖关系的函数时，会调用变量当时所管理的对象所属的类的函数
        {: id="20210310231224-ga3fp47" updated="20210311174156"}
      {: id="20210310231813-pbiheud"}
    - {: id="20210310231812-3n8pd40"}类型系统
      {: id="20210310231812-jmwouzb" updated="20210310231818"}

      - {: id="20210310231819-4x11fta"}单根结构
        {: id="20210310231819-9zwgyrh" updated="20210310231825"}

        - {: id="20210310231827-vgqhkwb"}所有类都继承于`Object`类
          {: id="20210310231827-0ohem14" updated="20210310231844"}

          - {: id="20210310232601-9oa4exy"}`toString()`
            {: id="20210310232601-ya3wtwt" updated="20210310232612"}
          - {: id="20210310232614-verwd3w"}`equals()`
            {: id="20210310232614-ul8kl12" updated="20210312174104"}
          {: id="20210312175035-s14ytns"}
        {: id="20210312175035-ga7isou"}
      {: id="20210312175041-q55qmgq"}
    - {: id="20210312175034-q8egol8" updated="20210312175034"}可扩展性
      {: id="20210312175041-wx6bjaa" updated="20210312175050"}

      - {: id="20210312175050-y4nune6"}代码不经过修改就可以适应新的数据或内容
        {: id="20210312175050-s6sgulr" updated="20210312175134"}
      {: id="20210312175103-df744rg"}
    - {: id="20210312175102-3ihlkg9"}可维护性
      {: id="20210312175102-4h10o51" updated="20210312175106"}

      - {: id="20210312175106-2tjc2o3"}代码经过修改可以适应新的数据或内容
        {: id="20210312175106-l08ffwf" updated="20210312175144"}
      {: id="20210312175206-f4rg4p4"}
    {: id="20210312175206-f2yw7dj"}
  {: id="20210312175207-md9j6cq"}
- {: id="20210312175205-arepkzo"}设计原则
  {: id="20210312175205-y9rbfst" updated="20210312175210"}

  - {: id="20210312233842-e00s5w2"}消除代码复制
    {: id="20210312233842-nx8hhx2" updated="20210312233852"}
  - {: id="20210312233852-u0ihigk"}封装降低耦合
    {: id="20210312233852-dfgiafi" updated="20210312234134"}
  - {: id="20210312234130-ew3tbwc"}可扩展性
    {: id="20210312234134-w98jmry" updated="20210312234138"}

    - {: id="20210312234317-okas9xw"}拒绝硬编码
      {: id="20210312234317-1oxt5ka" updated="20210312234326"}
    {: id="20210312234934-f9yinb3"}
  - {: id="20210312234933-cogiem8"}框架加数据
    {: id="20210312234933-imvuzfg" updated="20210312234955"}

    - {: id="20210312235000-c3egjcp"}提高可扩展性
      {: id="20210312235000-g7k6aff" updated="20210312235034"}
    {: id="20210313000254-q8z0a5i"}
  {: id="20210313000254-sgh1wtq"}
- {: id="20210313151617-m2qmegk"}抽象与接口
  {: id="20210313000253-692xq93" updated="20210313000305"}

  - {: id="20210313151617-84oknuc" updated="20210313151621"}数据与表现分离
    {: id="20210313154950-2v01mxt" updated="20210313154957"}
  - {: id="20210313154949-u0gyg40"}抽象
    {: id="20210313154949-kmw9hw3" updated="20210313154949"}

    - {: id="20210313000306-told0zd"}我们用abstract关键字来定义抽象类。抽象类的作用仅仅是表达接口，而不是具体的实现细节。抽象类中可以存在抽象方法。抽象方法也是使用abstract关键字来修饰。抽象的方法是不完全的，它只是一个方法签名而完全没有方法体。
      {: id="20210313000306-yaphktw"}
    - {: id="20210313000334-0v9di7b"}如果一个类有了一个抽象的方法，这个类就必须声明为抽象类。如果父类是抽象类，那么子类必须覆盖所有在父类中的抽象方法，否则子类也成为一个抽象类。一个抽象类可以没有任何抽象方法，所有的方法都有方法体，但是整个类是抽象的。设计这样的抽象类主要是为了防止制造它的对象出来。
      {: id="20210313000334-9urpgbt"}
    - {: id="20210313120729-swdpvgy"}抽象函数/抽象类
      {: id="20210313120729-g0nl4ak"}

      - {: id="20210313120736-jkwyizm"}抽象函数—表达概念而无法实现具体代码的函数
        {: id="20210313120736-2nz5y8y" updated="20210313120736"}
      - {: id="20210313120742-kv8vkb8"}抽象类—表达概念而无法构造出实体的类
        {: id="20210313120742-uq0manx" updated="20210313120742"}
      - {: id="20210313120746-yuait72"}带有 abstract修饰符的函数
        {: id="20210313120746-0297d4m" updated="20210313120746"}
      - {: id="20210313120751-3vxb219"}有抽象函数的类一定是抽象类
        {: id="20210313120751-iicsetx" updated="20210313120751"}
      - {: id="20210313120754-t19xy7j"}抽象类不能制造对象
        {: id="20210313120754-lgrtivx" updated="20210313120754"}
      - {: id="20210313120759-nym4y6w"}但是可以定义变量
        {: id="20210313120759-md49wuz" updated="20210313120759"}
      - {: id="20210313120804-7er5d2e"}任何继承了抽象类的非抽象类的对象可以付给这个变量
        {: id="20210313120804-48a1m3v" updated="20210313120804"}
      {: id="20210313121629-4lbffgp"}
    - {: id="20210313121627-v2mxwnh"}实现抽象函数
      {: id="20210313121627-4597jb8"}

      - {: id="20210313121633-zplpjqt"}继承自抽象类的子类必须覆盖父类中的抽象函数
        {: id="20210313121633-ltt2ckc" updated="20210313121633"}
      - {: id="20210313121639-1ueg5fl"}否则自己成为抽象类
        {: id="20210313121639-smk6r1r" updated="20210313121639"}
      {: id="20210313151636-lkrgsp1"}
    {: id="20210313151636-2yfuzqb"}
  - {: id="20210313151635-mehweui"}接口
    {: id="20210313151635-kaul9z8"}

    - {: id="20210313151642-a9sv4oo"}接口是纯抽象类
      {: id="20210313151642-ngx162g" updated="20210313151642"}

      - {: id="20210313151645-f9g2ysq"}所有的成员函数都是抽象函数
        {: id="20210313151645-rohuxaf" updated="20210313151645"}
      - {: id="20210313151648-3dgybd0"}所有的成员变量都是 public static final
        {: id="20210313151648-mpkp9wg" updated="20210313151652"}
      {: id="20210313151654-s0hxvaf"}
    - {: id="20210313151653-qim4l24"}接口规定了长什么样，但是不管里面有什么
      {: id="20210313151653-qczcbgo" updated="20210313151653"}
    - {: id="20210313154404-j20iz3p"}面向接口的编程方式
      {: id="20210313154404-hql95ck"}

      - {: id="20210313154408-7n2tj0j"}设计程序时先定义接口，再实现类
        {: id="20210313154408-0nsttzf" updated="20210313154407"}
      - {: id="20210313154416-14ep3fp"}任何需要在函数间传入传出的一定是接口而不是具体的类
        {: id="20210313154416-n8i9oea" updated="20210313193342"}
      - {: id="20210313154426-jyxej4q"}是Java成功的关键之一，因为极适合多人同时写一个大程序
        {: id="20210313154426-ybs9gqa" updated="20210313154426"}
      - {: id="20210313154520-uljz6et"}也是Java被批评的要点之一，因为代码量膨胀起来很快
        {: id="20210313154520-c80rz88"}
      {: id="20210313155023-09unxyk"}
    {: id="20210313155023-r6c40ly"}
  {: id="20210313155024-nrucaqd"}
- {: id="20210313155022-9oxg1vx"}控制反转与MVC模式
  {: id="20210313155022-rucunr6" updated="20210313155056"}

  - {: id="20210313155056-rkfzvfr"}控制反转
    {: id="20210313155056-f95znzr" updated="20210313155059"}

    - {: id="20210313155100-hy3mms9"}内部类
      {: id="20210313161040-rviyjx6" updated="20210313161049"}

      - {: id="20210313161459-5dbzqzz"}就是指一个类定义在另一个类的内部，从而成为外部类的一个成员。因此一个类中可以有成员变量、方法，还可以有内部类。实际上Java的内部类可以被称为成员类，内部类实际上是它所在类的成员。所以内部类也就具有和成员变量、成员方法相同的性质。比如，成员方法可以访问私有变量，那么成员类也可以访问私有变量了。也就是说，成员类中的成员方法都可以访问成员类所在类的私有变量。内部类最重要的特点就是能够访问外部类的所有成员。
        {: id="20210313161459-csvophd" updated="20210313161459"}
      - {: id="20210313161640-hdi0h91"}定义在别的类内部、函数内部的类
        {: id="20210313161640-obvgkig" updated="20210313161648"}
      - {: id="20210313161649-9vp8i5t"}内部类能直接访问外部的全部资源
        {: id="20210313161649-79lz74f" updated="20210313161649"}

        - {: id="20210313161652-8vc6t4l"}包括任何私有的成员
          {: id="20210313161652-x3k80bd" updated="20210313161657"}
        - {: id="20210313161657-mduvg8x"}外部是函数时，只能访问那个函数里final的变量
          {: id="20210313161657-kstfts1" updated="20210313161709"}
        {: id="20210313161653-jz818qa"}
      {: id="20210313161503-nbyayhq"}
    - {: id="20210313161502-3s3xg1y"}匿名类（内部类的一种）
      {: id="20210313161502-v6w7p3h" updated="20210313162134"}

      - {: id="20210313161521-g9asgbr"}在new对象的时候给出的类的定义形成了匿名类
        {: id="20210313161521-cw8c6vt" updated="20210313161521"}
      - {: id="20210313161529-u20q1hx"}匿名类可以继承某类，也可以实现某接口
        {: id="20210313161529-29eszy4" updated="20210313161529"}
      - {: id="20210313161541-4ey960o"}Swing的消息机制广泛使用匿名类
        {: id="20210313161541-bqih8xj" updated="20210313161541"}
      {: id="20210313162250-79sx8u7"}
    - {: id="20210313162249-aj5vp1o"}注入反转
      {: id="20210313162249-y898wbp"}

      - {: id="20210313162306-1uprzgw"}由按钮公布一个守听者接口和一对注册注销函数
        {: id="20210313162306-jvfmymh" updated="20210313162306"}
      - {: id="20210313162324-oszrgwm"}你的代码实现那个接口，将守听者对象注册在按钮上
        {: id="20210313162324-16rq1qf" updated="20210313162324"}
      - {: id="20210313162333-vd64uiz"}一旦按钮被按下，就会反过来调用你的守听者对象的某个函数
        {: id="20210313162333-adh5mkn" updated="20210313162336"}
      {: id="20210313163141-m2x4qa6"}
    {: id="20210313163141-qvqvapw"}
  - {: id="20210313163140-g6locf1"}MVC模式
    {: id="20210313163140-eu2o7pu" updated="20210313163145"}

    - {: id="20210313163145-n5nd81a"}数据、表现和控制三者分离，各负其责
      {: id="20210313163145-jr91gla" updated="20210313163152"}

      - {: id="20210313163204-f8t2tl9"}M= Model（模型）
        {: id="20210313163204-2id5ph4" updated="20210313163204"}
      - {: id="20210313163208-jgvsvcf"}V=VieW（表现）
        {: id="20210313163208-z2mwpog" updated="20210313163208"}
      - {: id="20210313163210-c53u75k"}C= Contro（控制）
        {: id="20210313163210-qgc3iqs" updated="20210313163220"}
      {: id="20210313163222-nukxyks"}
    - {: id="20210313163221-aq0j8gk"}模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新
      {: id="20210313163221-i14e4tk" updated="20210313163221"}
    - {: id="20210313163227-9z95ct1"}表现：从模型获得数据，根据数据画出表现
      {: id="20210313163227-i6op6ha" updated="20210313163227"}
    - {: id="20210313163230-6xydd6g"}控制：从用户得到输入，根据输人调整数据
      {: id="20210313163230-dr5l0e2" updated="20210313163230"}
    {: id="20210313163452-zkxnybk"}
  {: id="20210313163453-iz87rn3"}
- {: id="20210313163451-96cgwvv"}异常处理与输入输出
  {: id="20210313163451-k9kh4dt" updated="20210313163502"}

  - {: id="20210313165705-y2ktudq"}异常
    {: id="20210313165705-6g9vor2" updated="20210313165712"}

    - {: id="20210313170108-pzniysp"}异常一旦发生，不意味着程序会终止
      {: id="20210313170108-jp5zq4f" updated="20210313170124"}
    - {: id="20210313172045-tpwbjzp"}有不寻常的事情发生了
      {: id="20210313172045-l0veitc"}
    - {: id="20210313172102-f0z3822"}当这个事情发生的时候，原本打算要接着做的事情不能再继续了，必须得要停下来，让其他地方的某段代码来处理
      {: id="20210313172102-1e0xv1c" updated="20210313172102"}
    - {: id="20210313172107-5998627"}异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码
      {: id="20210313172107-evza0f1" updated="20210313172106"}
    - {: id="20210313172852-bfl2lrr"}catch会按照书写的顺序来捕捉异常
      {: id="20210313172852-58wi4sd" updated="20210313172913"}

      - {: id="20210313172913-q5d75mz"}可以通过父类异常的参数来捕捉子类异常，并且通过在上面已经捕捉过父类异常，再捕捉子类异常会报错
        {: id="20210313172913-68ykjow" updated="20210313173211"}
      {: id="20210313173347-cw2jepr"}
    - {: id="20210313173346-2w5wjoh"}异常声明
      {: id="20210313173632-kpbahp3"}

      - {: id="20210313173646-ajvgmld"}如果你调用一个声明会抛出异常的函数，那么你必须：
        {: id="20210313173646-6gr30ny" updated="20210313173646"}

        - {: id="20210313173653-ck0m6d3"}把函数的调用放在try块中，并设置cath来捕捉所有可能抛出的异常；
          {: id="20210313173653-viwjqwz" updated="20210313173653"}
        - {: id="20210313173657-gg7akqs"}或声明自己会抛出无法处理的异常
          {: id="20210313173657-4wl4v88" updated="20210313173657"}
        {: id="20210313173653-vyqn2x8"}
      {: id="20210313173646-5hkbkz0"}
    - {: id="20210313173632-877rdcq"}运行时刻异常
      {: id="20210313173632-4yp2dum" updated="20210313173632"}

      - {: id="20210313173418-gerssu5"}像 ArraylndexOutOfBounds Exception这样的异常是不需要声明的
        {: id="20210313173418-nrlc1f9" updated="20210313173425"}
      - {: id="20210313173429-scisp7f"}但是如果没有适当的机制来捕捉，就会最终导致程序终止
        {: id="20210313173429-x0kfocw" updated="20210313173429"}
      {: id="20210313173600-jwaf3yt"}
    - {: id="20210313173559-uiw9hym"}异常声明遇到继承关系
      {: id="20210313173559-4a6iy2b"}

      - {: id="20210313173603-5saiplr"}当覆盖一个函数的时候，子类不能声明抛出比父类的版本更多的异常
        {: id="20210313173603-rdhwpyt" updated="20210313173603"}
      - {: id="20210313173608-ungqont"}在子类的构造函数中，必须声明父类可能抛出的全部异常
        {: id="20210313173608-arlsehd" updated="20210313173608"}
      {: id="20210313174347-08ilo4u"}
    {: id="20210313174347-vuawt2s"}
  - {: id="20210313174345-equhp9j"}流
    {: id="20210313174345-vfl3oly" updated="20210313174351"}

    - {: id="20210313174351-o6re7fk"}流的基础类
      {: id="20210313174351-wdq63kq"}

      - {: id="20210313174655-emj7dp8"}Input stream
        {: id="20210313174655-kyeyc91" updated="20210313174658"}
      - {: id="20210313174658-5zunuya"}Output Stream
        {: id="20210313174658-rjl2za1" updated="20210313174702"}
      - {: id="20210313174703-cl7d6nk"}[Java™ Platform, Standard Edition 8 API Specification](http://docs.oracle.com/javase/8/docs/api/overview-summary.html)
        {: id="20210313174703-8oyc0bt" updated="20210313175100"}
      {: id="20210313175146-2120612"}
    - {: id="20210313193342-1wvbxeo"}文件流
      {: id="20210313195802-gjoudpd" updated="20210313202332"}

      - {: id="20210313202332-rrey88a"}FileInputStream
        {: id="20210313202332-7qu2tuy" updated="20210313202336"}
      - {: id="20210313202337-q7ibqh9"}File Output Stream
        {: id="20210313202337-rnxtrtx" updated="20210313202337"}
      - {: id="20210313202340-tjvmdeq"}对文件作读写操作
        {: id="20210313202340-d6k1dx6" updated="20210313202340"}
      - {: id="20210313202348-nvpru5o"}实际工程中已经较少使用
        {: id="20210313202348-kk4vqx8" updated="20210313202352"}

        - {: id="20210313202353-o1t1pnc"}更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信
          {: id="20210313202353-prari51" updated="20210313202404"}
        - {: id="20210313202405-sdzjavp"}具体的文件读写往往有更专业的类，比如配置文件和日志文件
          {: id="20210313202405-zq908o4" updated="20210313202405"}
        {: id="20210313204946-dpgwpt8"}
      {: id="20210313204947-nwyiuvt"}
    - {: id="20210313204945-n89d3g0"}流过滤器
      {: id="20210313204945-2gd4j70" updated="20210313205109"}

      - {: id="20210313205127-rn7u9ep"}以一个介质流对象为基础层层构建过滤器流，最终形成的流对象能在数据的输入输出过程中，逐层使用过滤器流的方法来读写数据
        {: id="20210313205127-ya7bm04"}
      {: id="20210313210914-ubmdaei"}
    - {: id="20210313210909-ym1de1e"}文本输入输出
      {: id="20210313210909-9n6ht9y" updated="20210313210918"}

      - {: id="20210313210920-f50k57a"}Reader/Writer
        {: id="20210313210920-djfu3nw"}

        - {: id="20210313210931-vprd94j"}二进制数据采用 InputStream/Output Stream
          {: id="20210313210931-ev6l71c" updated="20210313210931"}
        - {: id="20210313210935-tm4k7pf"}文本数据采用 Reader/Writer
          {: id="20210313210935-epiku7t" updated="20210313210935"}
        {: id="20210313210933-h0w0tc4"}
      {: id="20210313210920-nhcspr1"}
    {: id="20210313174352-3abbs3r"}
  {: id="20210313165705-4mifk4j"}
{: id="20210307230331-ls0w7mt" fold="0" updated="20210313210930"}

{: id="20210312175031-b60at18"}


{: id="20210307230331-u0ainpx" type="doc"}
