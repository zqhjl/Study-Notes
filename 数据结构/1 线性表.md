## 线性表的定义和特点
{: id="20210118164505-dl01jw9" fold="0"}

### 定义
{: id="20210118165300-3ewxa74" fold="0"}

- {: id="20210118215630-py5r3fx"}由 $n\ (n\geq0)$ 个数据特性相同的((20210118115037-6h08c9j "数据元素"))构成的有限序列
  {: id="20210201004639-v8ov2r9" fold="0"}
- {: id="20210201010902-w3uufa6"}长度
  {: id="20210201010902-nxihnl9"}

  - {: id="20210201010907-1e73sup"}((20210118115037-6h08c9j "数据元素"))的个数 $n\ (n\geq 0)$
    {: id="20210201010907-rchyq5b"}
  - {: id="20210201010915-d4iediv"}$n=0$ 时称为空表
    {: id="20210201010915-623dv1b"}
  {: id="20210201010908-9xj3v22"}
{: id="20210201010632-fb6ngrj" parent-fold="0"}

### 非空线性表特点
{: id="20210118215619-en173rn" fold="0" parent-fold="0"}

- {: id="20210118211221-t8xpzbr"}存在首((20210118115037-6h08c9j "元素"))
  {: id="20210201004639-i8913ll"}
- {: id="20210118211234-mtom7t0"}存在尾((20210118115037-6h08c9j "元素"))
  {: id="20210201004639-8h3dyj1"}
- {: id="20210118211245-jcffbt7"}除首((20210118115037-6h08c9j "元素"))外，每个((20210118115037-6h08c9j "元素"))只有一个前驱
  {: id="20210201004639-npnqqnn"}
- {: id="20210118211337-iqdkhx1"}除尾((20210118115037-6h08c9j "元素"))外，每个((20210118115037-6h08c9j "元素"))只有一个后继
  {: id="20210201004639-6r8efjz"}
{: id="20210118211221-fcejnmm" fold="0" parent-fold="0"}

### 有序表（$Ordered List）
{: id="20210126223100-4wz6lin" parent-fold="0" updated="20210325164419"}

- {: id="20210126223152-7oeqhw5"}((20210118164505-dl01jw9 "线性表"))中的((20210118115037-6h08c9j "数据元素"))
  {: id="20210201004639-x5peuaj"}

  - {: id="20210203185937-wucng3i"}相互之间可以比较
    {: id="20210203185937-qqybjau"}
  - {: id="20210203185951-y08i8u9"}依值非递减或非递增有序排列
    {: id="20210203185951-hlzlqh3"}
  {: id="20210203185937-s7ryvju"}
{: id="20210126223152-346tqqz" parent-fold="0"}

## 线性表的顺序表示和实现
{: id="20210118212213-jp1enaw"}

### 顺序表（Sequential List）
{: id="20210118221559-x45ini8"}

- {: id="20210122171527-9vemi4c"}定义：((20210118104804-olw0skv "顺序存储结构"))实现的((20210118164505-dl01jw9 "线性表"))
  {: id="20210201004639-cqexhtq" updated="20210325161044"}
- {: id="20210202234141-fn7cv3f"}特点
  {: id="20210202234141-ugx336k"}

  - {: id="20210122171533-130wsr9"}随机存取
    {: id="20210201004639-m2esrno"}
  - {: id="20210124224937-kf6w6u4"}只要确定了存储的起始位置，表中任一((20210118115037-6h08c9j "数据元素"))都可以随机存取
    {: id="20210201004639-fgu1i77"}
  {: id="20210124224937-a3sxgi8"}
- {: id="20210224101507-ih8yjsc"}存储结构定义
  {: id="20210224101507-sjvrm8a"}

  - {: id="20210122171539-e95suyv"}
    ```cpp
    #define MAXSIZE 100 //顺序表可能达到的最大长度
    typedef struct
    {
        ElemType *elem; //存储空间的基地址
        int length;     //当前长度
    } SqList;           //顺序表的结构类型为SqList
    ```
    {: id="20210122171558-n8yfhsw"}
  {: id="20210224101507-9tdnlz8"}
{: id="20210122171526-cjzpj04"}

### 顺序表中基本操作的实现
{: id="20210122171503-hn78kmz"}

- {: id="20210224101414-maxciqg"}初始化
  {: id="20210224101414-9680zs5"}

  - {: id="20210122171626-vjxwqq9"}
    ```cpp
    Status InitList(SqList &L)
    {                                   //构造一个空的顺序表L
        L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间
        if (!L.elem)
            exit(OVERFLOW); //存储空间分配失败退出
        L.length = 0;       //空表长度为0
        return OK;
    }
    ```
    {: id="20210122171651-mwdpgrn"}
  {: id="20210224101416-x40j9ov"}
- {: id="20210224101424-ihkyxbb"}取值
  {: id="20210224101424-p9ovugf"}

  - {: id="20210122171646-0qrfjf0"}
    ```cpp
    Status GetElem(SqList L, int i, ElemType &e)
    {
        if (i < 1 || i > L.length)
            return ERROR;  //判断i值是否合理，若不合理，返回ERROR
        e = L.elem[i - 1]; //elem[i-1]单元存储第i个数据元素
        return OK;
    }
    ```
    {: id="20210122171711-ttocovh"}
  {: id="20210224101430-gm9v2dg"}
- {: id="20210224101445-jddl6h4"}查找
  {: id="20210224101445-5ljonry"}

  - {: id="20210122171701-5bhvxeo"}
    ```cpp
    int LocateElem(SqList L, ElemType e)
    { //在顺序表L中查找值为e的数据元素，返回其序号
        for (int i = 0; i < L.length; i++)
            if (L.elem[i] == e)
                return i + 1; //查找成功，返回序号i+1
        return 0;             //查找失败，返回0
    }
    ```
    {: id="20210122172116-pyj38fz"}
  - {: id="20210122171901-mjszu6m"}((20210122235027-da94nkl "平均查找长度"))： $ASL=\frac{1}{n}\sum\limits_{i=1}^ni=\frac{n+1}{2}$
    {: id="20210201004639-tpe18yr"}
  - {: id="20210123092948-8piv4e2"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
    {: id="20210201004639-p4ih4mb"}
  {: id="20210122171901-0w723jj"}
- {: id="20210224101557-lm85tl8"}插入
  {: id="20210224101557-bpwxcl4"}

  - {: id="20210122172255-3b5tn2h"}
    ```cpp
    Status ListInsert(SqList &L, int i, ElemType e)
    { //在顺序表L中第i个位置插入新的元素e，i的合法范围是1<=i<=L.length+1
        if ((i < 1) || (i > L.length + 1))
            return ERROR; //i值不合法
        if (L.length == MAXSIZE)
            return ERROR; //当前存储空间已满
        for (int j = L.length - 1; j >= i - 1; j--)
            L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移
        L.elem[i - 1] = e;             //将新元素e放入第i个位置
        ++L.length;                    //表长加1
        return OK;
    }
    ```
    {: id="20210122172329-d0tqugs" updated="20210224101623"}
  - {: id="20210122153334-1a0kta8"}插入时所需移动((20210118115037-6h08c9j "元素"))的期望值
    {: id="20210201004639-s6xos4j"}

    - {: id="20210122153602-54fwzgb"}记作
      {: id="20210201004639-1r0oxak"}

      - {: id="20210202234302-h2d63wc"}$E_{ins}=\frac{1}{n+1}\sum\limits_{1=1}^{n+1}(n-i+1)=\frac{n}{2}$
        {: id="20210202234302-o22i86t"}
      {: id="20210202234302-ubbg6a6"}
    - {: id="20210122155328-swyaopq"}((20210122234918-g8kd7s8 "平均时间复杂度"))
      {: id="20210201004639-qgwzvlw"}

      - {: id="20210202234308-tizhmse"}$O(n)$
        {: id="20210202234308-70fade4"}
      {: id="20210202234308-rid2qzv"}
    {: id="20210122153603-0dphilq"}
  {: id="20210224101618-681j151"}
- {: id="20210224101643-nwrsphp"}删除
  {: id="20210224101643-rrk3j05"}

  - {: id="20210122155407-zv7ifyp"}
    ```cpp
    Status ListDelete(SqList &L, int i)
    { //在顺序表L中删除第i个元素，i的合法范围是1<=i<=L.length
        if ((i < 1) || (i > L.length))
            return ERROR; //i值不合法
        if (L.length == 0)
            return ERROR; //当前存储空间已空
        for (int j = i; j <= L.length - 1; j++)
            L.elem[j - 1] = L.elem[j]; //被删除元素之后的元素前移
        --L.length;                    //表长减1
        return OK;
    }
    ```
    {: id="20210122155415-lzikhtu"}
  - {: id="20210122155919-2ijnrwj"}删除时所需移动((20210118115037-6h08c9j "元素"))的期望值
    {: id="20210201004639-ydlms4r"}

    - {: id="20210122155919-0vl90z5"}记作
      {: id="20210201004639-402fjz9"}

      - {: id="20210202234321-kcmgjzp"}$E_{del}=\frac{1}{n}\sum\limits_{1=1}^{n}(n-i)=\frac{n-1}{2}$
        {: id="20210202234321-n290jce"}
      {: id="20210202234321-hoz7yft"}
    - {: id="20210122155919-h0qxiqb" fold="0"}((20210122234918-g8kd7s8 "平均时间复杂度"))
      {: id="20210201004639-3sw00ju"}

      - {: id="20210202234325-kvpjft8"}$O(n)$
        {: id="20210202234325-dheptn6"}
      {: id="20210202234325-snhqxnp"}
    {: id="20210122155919-ek5fpl8"}
  {: id="20210121213342-kv35azy"}
{: id="20210122172329-bp1x1r8"}

## 线性表的链式表示和实现
{: id="20210122160959-vsxwjkq"}

### 单链表（线性链表）
{: id="20210122165817-v6jc9n3"}

- {: id="20210122205231-qlpdxw3"}定义
  {: id="20210201004639-tq5xg8y"}

  - {: id="20210202234333-lut9thh"}每个((20210122170313-wsturbw "结点"))只包含一个((20210122170507-2f0rmf4 "指针域"))的((20210122170513-jdlg2cq "链表"))
    {: id="20210202234333-9mmcizx"}
  {: id="20210202234333-5n79t6z"}
- {: id="20210123222507-xraq58g"}特点
  {: id="20210201004639-ci5tce2"}

  - {: id="20210202234336-32a0x14"}顺序存取
    {: id="20210202234336-hwtku0y"}
  {: id="20210202234336-sst4klv"}
- {: id="20210224101709-jzlgvn5"}存储结构定义
  {: id="20210224101709-egtlyqb"}

  - {: id="20210122210316-061c30k"}
    ```cpp
    typedef struct LNode
    {
        ElemType data;      //结点的数据域
        struct LNode *next; //结点的指针域
    } LNode, *LinkList;     //LinkList为指向结构体LNode的指针类型
    ```
    {: id="20210123221049-i23keth"}
  {: id="20210224101710-qdiyl64"}
{: id="20210122165817-bst0002"}

### 单链表中基本操作的实现
{: id="20210122171429-x8o9ygx"}

- {: id="20210224101821-v7l0x6l"}初始化
  {: id="20210224101821-ttkpg6l"}

  - {: id="20210122213437-byet950"}
    ```cpp
    Status InitList(LinkList &L)
    {                   //构造一个空的单链表L
        L = new LNode;  //生成新结点作为头结点，用头指针L指向头结点
        L->next = NULL; //头结点的指针域置空
        return OK;
    }
    ```
    {: id="20210122214508-dt3xy8u"}
  {: id="20210224101821-efpqlty"}
- {: id="20210224101827-oedvyh6"}取值
  {: id="20210224101827-tptcem5"}

  - {: id="20210122213445-1g01ilf"}
    ```cpp
    Status GetElem(LinkList L, int i, ElemType &e)
    { //在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
        LNode *p = L->next;  //初始化，p指向首元结点
        int j = 1;           //计数器j初值赋为1
        while (p && (j < i)) //顺链域向后扫描，直到p为空或p指向第i个元素
        {
            p = p->next; //p指向下一个结点
            ++j;         //计数器j相应加1
        }
        if (!p || (j > i))
            return ERROR; //i值不合法i>n或i<=0
        e = p->data;      //取第i个结点的数据域
        return OK;
    }
    ```
    {: id="20210123093944-45hcp43" updated="20210224204956"}
  - {: id="20210122232854-k2yvh2x"}((20210122235027-da94nkl "平均查找长度"))
    {: id="20210201004639-u6qldkx"}

    - {: id="20210202234343-4xizcaf"}$ASL=\frac{1}{n}\sum\limits_{i=1}^n(i-1)=\frac{n-1}{2}$
      {: id="20210202234343-5127st2"}
    {: id="20210202234344-awptwhy"}
  - {: id="20210122233739-rglmn6y"}((20210122234918-g8kd7s8 "平均时间复杂度"))
    {: id="20210201004639-07on0gn"}

    - {: id="20210202234353-yw5r7hd"}$O(n)$
      {: id="20210202234353-t8a7cvc"}
    {: id="20210202234353-99ycyw0"}
  {: id="20210122232854-sn0v4yz"}
- {: id="20210202234403-xa4zksm"}查找
  {: id="20210224101941-pze79rb"}

  - {: id="20210122214607-vb72g2j"}
    ```cpp
    LNode *LocateElem(LinkList L, ElemType e)
    {
        LNode *p = L->next;       //初始化，p指向首元结点
        while (p && p->data != e) //顺链域向后扫描，直到p为空或p所指结点的数据域等于e
            p = p->next;          //p指向下一个结点
        return p;                 //查找成功返回值为e的节点地址p，查找失败p为NULL
    }
    ```
    {: id="20210123093944-grbkpw4"}
  - {: id="20210201004639-931fkpy" updated="20210224102444"}!((20210202234343-4xizcaf "平均查找长度"))
    {: id="20210224102444-8pv4qqe" updated="20210224102512"}
  - {: id="20210201004639-2z7kso6" updated="20210224102551"}!((20210202234353-yw5r7hd "平均时间复杂度"))
    {: id="20210224102606-f46qlbk" updated="20210224102649"}
  {: id="20210123094151-hwzx3ps"}
{: id="20210123094037-a3we97u" updated="20210224102636"}

- {: id="20210224102023-55re2oz"}插入
  {: id="20210224102023-99gzc5m"}

  - {: id="20210122214615-iw8il9o"}
    ```cpp
    Status ListInsert(LinkList &L, int i, ElemType e)
    { //在带头结点的单链表L中第i个位置插入值为e的新结点
        LNode *p = L;
        int j = 0;
        while (p && (j < i - 1)) //查找第i-1个结点，p指向该结点
        {
            p = p->next;
            ++j;
        }
        if (!p || j > i - 1)
            return ERROR;     //i值不合法i>n+1或i<1
        LNode *s = new LNode; //生成新结点*s
        s->data = e;          //将结点*s的数据域置为e
        s->next = p->next;    //将结点*s的指针域域指向结点a_i
        p->next = s;          //将结点*p的指针域指向结点*s
        return OK;
    }
    ```
    {: id="20210123093944-7jbeenw"}
  - {: id="20210123095611-67rtsmy"}!((20210202234343-4xizcaf "平均查找长度（与取值相同）"))
    {: id="20210201004639-b7lv7bl" updated="20210224204719"}
  - {: id="20210123095611-lo34e1k"}!((20210202234353-yw5r7hd "平均时间复杂度"))
    {: id="20210201004639-3f4j8xm" updated="20210224102807"}
  {: id="20210123095611-50jo6nj"}
- {: id="20210224102902-dymjqui"}删除
  {: id="20210224102902-p0k1itc"}

  - {: id="20210122214618-hui6iyf"}
    ```cpp
    Status ListDelete(LinkList &L, int i)
    { //在带头结点的单链表L中，删除第i个元素
        LNode *p = L;
        int j = 0;
        while (p && (j < i - 1)) //查找第i-1个结点，p指向该结点
        {
            p = p->next;
            ++j;
        }
        if (!p || j > i - 1)
            return ERROR;   //i值不合法i>n+1或i<1
        LNode *q = p->next; //临时保存被删结点的地址以备释放
        p->next = q->next;  //改变删除结点前驱结点的指针域
        delete q;           //释放删除结点的空间
        return OK;
    }
    ```
    {: id="20210123093944-3gi6piu"}
  - {: id="20210123100402-g5r0plw"}!((20210202234343-4xizcaf "平均查找长度"))
    {: id="20210201004639-wh1c4cv" updated="20210224102856"}
  - {: id="20210123100402-p9o9g1w"}!((20210202234343-4xizcaf "平均查找长度"))
    {: id="20210201004639-75s70ve" updated="20210224102959"}
  {: id="20210123100402-gh8fnb5"}
- {: id="20210122214634-ok1ahv8"}创建
  {: id="20210123093944-uhjbmkw"}

  - {: id="20210224103004-8s7wt29"}前插法
    {: id="20210224103004-95y9m1l"}

    - {: id="20210123100447-n554jgg"}
      ```cpp
      void CreateList_H(LinkList &L, int n)
      { //逆位序输入n个元素的值，建立带表头结点的单链表L
          L = new LNode;
          L->next = NULL; //先建立一个带头结点的空链表
          for (int i = 0; i < n; i++)
          {
              LNode *p = new LNode; //生成新结点*p
              cin >> p->data;       //输入元素值付给新结点*p的数据域
              p->next = L->next;
              L->next = p; //将新结点*p插入到头结点之后
          }
      }
      ```
      {: id="20210123215004-doetbdw"}
    {: id="20210224103004-couh8l9"}
  - {: id="20210224103020-l5spmyn"}后插法
    {: id="20210224103020-txnq69q"}

    - {: id="20210123100512-hats6hl"}
      ```cpp
      void CreateList_R(LinkList &L, int n)
      { //正位序输入n个元素的值，建立带表头结点的单链表L
          L = new LNode;
          L->next = NULL; //先建立一个带头结点的空链表
          LNode *r = L;   //尾指针r指向头结点
          for (int i = 0; i < n; i++)
          {
              LNode *p = new LNode; //生成新结点*p
              cin >> p->data;       //输入元素值付给新结点*p的数据域
              p->next = NULL;
              r->next = p; //将新结点*p插入尾结点*r之后
              r = p;       //r指向新的尾结点*p
          }
      }
      ```
      {: id="20210123215357-7f31h5k"}
    {: id="20210224103020-tpyzux8"}
  {: id="20210123100447-34jzr1o"}
{: id="20210122213102-1b3mqto" updated="20210224102955"}

### 循环链表（Circular Linked List）
{: id="20210123100354-r2v1wny"}

- {: id="20210123220618-p5natq5"}定义
  {: id="20210201004639-18mv1r8"}

  - {: id="20210202234428-mio5rzw"}最后一个((20210122170313-wsturbw "结点"))的((20210122170507-2f0rmf4 "指针域"))向((20210123221816-14pna6b "头结点"))的((20210122165817-v6jc9n3 "单链表"))
    {: id="20210202234428-9u1g6of"}
  {: id="20210202234428-k5vjik0"}
- {: id="20210123223415-qukk1gb"}特点
  {: id="20210201004639-58x06og"}

  - {: id="20210123224630-x9lojyo"}遍历时判断当前指针是否指向表尾结点的终止条件与((20210122165817-v6jc9n3 "单链表"))不同
    {: id="20210201004639-y2xiivg"}
  - {: id="20210123224637-rnyr0ni"}设立尾指针可使表合并等操作简化
    {: id="20210201004639-qodslfv"}
  {: id="20210123224631-2v1sh2w"}
- {: id="20210123223115-rgjx758"}操作
  {: id="20210201004639-k3w10qg"}

  - {: id="20210202234440-fshpplc"}与((20210122165817-v6jc9n3 "单链表"))基本一致
    {: id="20210202234440-8y0oem5"}
  {: id="20210202234440-ypk04cb"}
{: id="20210123215423-1djpfaj"}

### 双向链表（Double Linked List）
{: id="20210123220740-vgcgkuh"}

- {: id="20210124174454-77jq20t"}定义
  {: id="20210201004639-kw0i3ss"}

  - {: id="20210124174550-p3wk88a"}每个((20210122170313-wsturbw "结点"))包含两个((20210122170507-2f0rmf4 "指针域"))的((20210122170513-jdlg2cq "链表"))
    {: id="20210201004639-h9pspfh"}
  - {: id="20210124174553-8zsiy7v"}一个指向直接后继，一个指向直接前驱
    {: id="20210201004639-7jhf7e4"}
  {: id="20210124174550-dgz901l"}
- {: id="20210124174559-ldzpsmn"}特点
  {: id="20210201004639-vtjujga"}

  - {: id="20210202234448-5cxj5jl"}查找直接前驱的执行时间为 $O(n)$
    {: id="20210202234448-29keg35"}
  {: id="20210202234448-n5x71h6"}
- {: id="20210224103046-eqp5de3"}存储结构定义
  {: id="20210224103046-xmb97ch"}

  - {: id="20210124174643-8wglocy"}
    ```cpp
    typedef struct DuLNode
    {
        ElemType data;         //数据域
        struct DuLNode *prior; //指向直接前驱
        struct DuLNode *next;  //指向直接后继
    } DuLNode, *DuLinkList;
    ```
    {: id="20210124203723-tmbbrzg"}
  {: id="20210224103046-k0ej0ab"}
- {: id="20210124203544-8qts81k"}操作
  {: id="20210201004639-bt29mos"}

  - {: id="20210124203611-a6zzer1"}取值、查找
    {: id="20210201004639-wvfjrtw"}

    - {: id="20210124203641-koohgpu"}与((20210122171429-x8o9ygx "单链表"))相同
      {: id="20210201004639-4xum3bq"}
    {: id="20210124203641-pynmxfm"}
  - {: id="20210224103103-tm3omrf"}插入
    {: id="20210224103103-zewz4cu"}

    - {: id="20210124203717-ok0uyk0"}
      ```cpp
      Status ListInsert_DuL(DuLinkList &L, int i, ElemType e)
      { //在带头结点的双向链表L中第i个位置之前插入元素e
          DuLNode *p;
          if (!(p = GetElem_DuL(L, i))) //在L中确定第i个元素的位置指针p
              return ERROR;             //p为NULL时，第i个元素不存在
          DuLNode *s = new DuLNode;     //生成新结点*s
          s->data = e;                  //将结点*s数据域置为e
          s->prior = p->prior;          //将结点*s插入L中
          p->prior->next = s;
          s->next = p;
          p->prior = s;
          return OK;
      }
      ```
      {: id="20210124203935-ct9a2q7"}
    {: id="20210224103104-xpqcgb7"}
  - {: id="20210224103113-phl8hqc"}删除
    {: id="20210224103113-u53j8f9"}

    - {: id="20210124203825-woj5nj1"}
      ```cpp
      Status ListDelete_Du(DuLinkList &L, int i)
      { //删除带头结点的双向链表L中的第i个元素
          DuLNode *p;
          if (!(p = GetElem_DuL(L, i))) //在L中确定第i个元素的位置指针p
              return ERROR;             //p为NULL时，第i个元素不存在
          p->prior->next = p->next;     //修改被删结点的前驱结点的后继指针
          p->next->prior = p->prior;    //修改被删结点的后继结点的前驱指针
          delete p;                     //释放被删结点的空间
          return OK;
      }
      ```
      {: id="20210124210510-wcoozih"}
    {: id="20210224103113-nwbdt8z"}
  {: id="20210124203611-e9zlsxr"}
{: id="20210124174428-ebs8334"}

## 顺序表和链表的比较
{: id="20210124210556-6bulkxh"}

### 空间性能的比较
{: id="20210124210623-4ru7p8h"}

- {: id="20210124210637-zutocn5"}存储空间的分配
  {: id="20210201004639-vambzpt"}

  - {: id="20210124210649-b2lyqhv"}((20210118212213-jp1enaw "顺序表"))的存储空间必须预先分配
    {: id="20210201004639-p92k58p"}
  - {: id="20210124210837-v7k61bx"}((20210122160959-vsxwjkq "链表"))的存储空间不需要预先分配
    {: id="20210201004639-cua9mgu"}
  {: id="20210124210650-7n9k32b"}
- {: id="20210124212232-5fetvde"}存储密度的大小
  {: id="20210201004639-qc4vv4v"}

  - {: id="20210124212254-d7ow63k"}存储密度 $=\frac{数据元素本身占用的存储量}{节点结构占用的存储量}$
    {: id="20210201004639-rfavs9w"}
  - {: id="20210124220955-q9wb7c9"}((20210118212213-jp1enaw "顺序表"))的((20210124212254-d7ow63k "存储密度")) $=$ 1
    {: id="20210201004639-qo6p29b"}
  - {: id="20210124221129-p344rrw"}((20210122160959-vsxwjkq "链表"))的((20210124212254-d7ow63k "存储密度")) $<$ 1
    {: id="20210201004639-qpgm1vb"}
  {: id="20210124212255-stzc1a1"}
{: id="20210124210635-x3jmnx5"}

### 时间性能的比较
{: id="20210124212156-wihfdpu"}

- {: id="20210124222603-st7ai54"}存取元素的效率
  {: id="20210201004639-qym04vc"}

  - {: id="20210124222610-683fupy"}((20210118212213-jp1enaw "顺序表"))是((20210122171533-130wsr9 "随机存取"))结构
    {: id="20210201004639-ncn9wgu"}
  - {: id="20210124222657-yt67c72"}((20210122160959-vsxwjkq "链表"))是((20210123222507-xraq58g "顺序存取"))结构
    {: id="20210201004639-c61ck7p"}
  {: id="20210124222610-ia1lfbo"}
- {: id="20210124222730-f2v6wdq"}插入和删除操作的效率
  {: id="20210201004639-67eu9kl"}

  - {: id="20210124222741-t86po4i"}((20210122160959-vsxwjkq "链表"))进行插入和删除时无需移动数据
    {: id="20210201004639-8cfcsd2"}
  - {: id="20210124223300-o1op16o"}((20210118212213-jp1enaw "顺序表"))进行插入和删除时平均要移动表中近一半的元素
    {: id="20210201004639-6jce8cq"}
  {: id="20210124222741-d19hdxb"}
{: id="20210124222231-smfohd5"}

## 线性表的应用
{: id="20210124223418-4bc5rgh"}

### 线性表的合并
{: id="20210126170222-ky2ciu9"}

- {: id="20210126171012-m57okwt"}算法描述
  {: id="20210201004639-3ro03k0"}

  ```cpp
  void MergeList(List &LA, List &LB)
  { //将所有在线性表LB中但不在线性表LA中的数据元素插入到LA中
      int m = ListLength(LA);
      int n = ListLength(LB); //求线性表的长度
      for (int i = 1; i < n; i++)
      {
          ElemType e;
          GetElem(LB, i, e);          //取LB中第i个数据元素赋给e
          if (!LocateElem(LA, e))     //LA中不存在和e相同的数据元素
              ListInsert(LA, ++m, e); //将e插在LA的最后
      }
  }
  ```
  {: id="20210126171040-45c4v0y"}
- {: id="20210126171031-7h8x933"}((20210118110555-49xon8e "时间复杂度"))
  {: id="20210201004639-z57pwb9"}

  - {: id="20210126171244-ne2o799"}((20210118104804-olw0skv "顺序存储结构"))
    {: id="20210201004639-1nm2uzd"}

    - {: id="20210202234500-4j0oy6u"}$O(m\times n)$
      {: id="20210202234500-8rd20td"}
    {: id="20210202234500-yy2xi2h"}
  - {: id="20210126171310-2xmor8u"}((20210118104812-quujvq4 "链式存储结构"))
    {: id="20210201004639-fliu4na"}

    - {: id="20210202234506-wuic24w"}$O(m\times n)$
      {: id="20210202234506-f2d5od3"}
    {: id="20210202234506-4hnho4s"}
  {: id="20210126171244-nyt3xey"}
{: id="20210126170331-ugxsw2w"}

### ((20210126223100-4wz6lin "有序表"))的合并
{: id="20210126171210-iupgakp"}

- {: id="20210126171223-0nv9c5j"}顺序((20210126223100-4wz6lin "有序表"))的合并
  {: id="20210201004639-1mupwv8"}

  - {: id="20210127101357-1a6rx2f"}算法描述
    {: id="20210201004639-4owxs5e"}

    ```cpp
    void MergeList_Sq(SqList LA, SqList LB, SqList &LC)
    { //已知顺序有序表LA和LB的元素按值非递减排列
      //归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列
        LC.length = LA.length + LB.length; //新表长度为待合并量表的长度之和
        LC.elem = new ElemType[LC.length]; //为合并后的新表分配一个数组空间
        ElemType *pc = LC.elem;            //指针pc指向信标的第一个元素
        ElemType *pa = LA.elem;
        ElemType *pb = LB.elem;                      //指针pa和pb的初值分别指向两个表的第一个元素
        ElemType *pa_last = LA.elem + LA.length - 1; //指针pa_last指向LA的最后一个元素
        ElemType *pb_last = LB.elem + LB.length - 1; //指针pb_last指向LB的最后一个元素
        while ((pa <= pa_last) && (pb <= pb_last))   //LA和LB均为到达表尾
        {
            if (*pa <= *pb)
                *pc++ = *pa++; //依次”摘取“量表中值较小的结点插入到LC的最后
            else
                *pc++ = *pb++;
        }
        while (pa <= pa_last)
            *pc++ = *pa++; //LB已到达表尾，依次将LA的剩余元素插入LC的最后
        while (pb <= pb_last)
            *pc++ = *pb++; //LA已到达表尾，依次将LB的剩余元素插入LC的最后
    }
    ```
    {: id="20210127101600-4t6ura1" updated="20210224204854"}
  - {: id="20210127101405-778e2uj"}((20210118110555-49xon8e "时间复杂度"))
    {: id="20210201004639-4lmhjmv"}

    - {: id="20210203191948-uworm5q"}$O(m+n)$
      {: id="20210203191948-ai7ntzo"}
    {: id="20210203191949-0ku4ksi"}
  - {: id="20210127101842-68y89s9"}((20210118114411-vsm7bt7 "空间复杂度"))
    {: id="20210201004639-61tmha0"}

    - {: id="20210203191952-u9hmjt3"}$O(m+n)$
      {: id="20210203191952-l9kncny"}
    {: id="20210203191952-jr9f3cd"}
  {: id="20210127101357-l0yp33t"}
- {: id="20210127101900-o2na2cs"}链式((20210126223100-4wz6lin "有序表"))的合并
  {: id="20210201004639-arb089o"}

  - {: id="20210127102121-nt4141p"}算法描述
    {: id="20210201004639-ffvbln6"}

    ```cpp
    void MergeList_L(LinkList &LA, LinkList &LB, LinkList &LC)
    {   //已知单链表LA和LB的元素按值非递减排列
        //归并LA和LB得到新的单链表LC，LC的元素也按值非递减排列
        LNode *pa = LA->next;
        LNode *pb = LB->next; //pa和pb的初值分别指向两个表的第一个结点
        LC = LA;              //用LA的头结点作为LC的头结点
        LNode *pc = LC;       //pc的初值指向LC的头结点
        while (pa && pb)
        { //LA和LB均为到达表尾，依次”摘取“量表中值较小的结点插入到LC的最后
            if (pa->data <= pb->data) //”摘取“pa所指结点
            {
                pc->next = pa; //将pa所指结点链接到pc所指结点之后
                pc = pa;       //pc指向pa
                pa = pa->next; //pa指向下一结点
            }
            else //”摘取“pb所指结点
            {
                pc->next = pb; //将pb所指结点链接到pc所指结点之后
                pc = pb;       //pc指向pb
                pb = pb->next; //pb指向下一结点
            }
        }
        pc->next = pa ? pa : pb; //将非空表的剩余端插入到pc所指结点之后
        delete LB;               //释放LB的头结点
    }
    ```
    {: id="20210127104757-160xpi3" updated="20210224204919"}
  - {: id="20210127102125-lcbj1h5"}((20210118110555-49xon8e "时间复杂度"))
    {: id="20210201004639-t10bjea"}

    - {: id="20210202234518-w56nqnq"}$O(m+n)$
      {: id="20210202234518-bzfkvec"}
    {: id="20210202234518-e16w9hd"}
  - {: id="20210127102435-vetin5w"}((20210118114411-vsm7bt7 "空间复杂度"))
    {: id="20210201004639-opm09pn"}

    - {: id="20210202234521-onkh9bz"}$O(1)$
      {: id="20210202234521-rdifnqw" updated="20210223232014"}
    {: id="20210202234521-25ouggg"}
  {: id="20210127102121-chirosk"}
{: id="20210126171221-g2mgx0o"}


{: id="20210118114241-m4h7oed" type="doc"}
