## 线性表的定义和特点
{: id="20210118164505-dl01jw9"}

### 定义
{: id="20210118165300-3ewxa74"}

- {: id="20210118215630-py5r3fx"}由 $n\ (n\geq0)$ 个数据特性相同的 ((20210118115037-6h08c9j "数据元素")) 构成的有限序列
- {: id="20210118215635-cx7brap"}长度
  - {: id="20210118215638-r1qwpm5"}((20210118115037-6h08c9j "数据元素")) 的个数 $n\ (n\geq 0)$
  - {: id="20210118215646-bpj7mu7"} $n=0$ 时称为空表
  {: id="20210118215638-c63w8jf"}
{: id="20210118215630-49n49rw"}

### 非空线性表特点
{: id="20210118215619-en173rn"}

- {: id="20210118211221-t8xpzbr"}存在首 ((20210118115037-6h08c9j "元素"))
- {: id="20210118211234-mtom7t0"}存在尾 ((20210118115037-6h08c9j "元素"))
- {: id="20210118211245-jcffbt7"}除首 ((20210118115037-6h08c9j "元素")) 外，每个 ((20210118115037-6h08c9j "元素")) 只有一个前驱
- {: id="20210118211337-iqdkhx1"}除尾 ((20210118115037-6h08c9j "元素")) 外，每个 ((20210118115037-6h08c9j "元素")) 只有一个后继
{: id="20210118211221-fcejnmm"}

## 线性表的顺序表示和实现
{: id="20210118212213-jp1enaw"}

### 顺序表（Sequential List）
{: id="20210118221559-x45ini8"}

- {: id="20210122171527-9vemi4c"}定义：((20210118104804-olw0skv "顺序存储结构")) 的 ((20210118164505-dl01jw9 "线性表"))
- {: id="20210122171533-130wsr9"}特点：随机存取
- {: id="20210122171539-e95suyv"}存储结构定义
  ```cpp
  #define MAXSIZE 100 //顺序表可能达到的最大长度
  typedef struct
  {
      ElemType *elem; //存储空间的基地址
      int length;     //当前长度
  } SqList;           //顺序表的结构类型为SqList
  ```
  {: id="20210122171558-n8yfhsw"}
{: id="20210122171526-cjzpj04"}

### 顺序表中基本操作的实现
{: id="20210122171503-hn78kmz" style="border-radius: 4px; transition: all 0.15s cubic-bezier(0, 0, 0.2, 1) 0ms; background-color: var(--b3-theme-primary-lightest); box-shadow: 4px 0px 0 var(--b3-theme-primary-lightest), -4px 0px 0 var(--b3-theme-primary-lightest);"}

- {: id="20210122171626-vjxwqq9"}初始化
  {: id="20210122172116-8k5sj3f"}

  ```cpp
  Status InitList(SqList &L)
  {                                   //构造一个空的顺序表L
      L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间
      if (!L.elem)
          exit(OVERFLOW); //存储空间分配失败退出
      L.length = 0;       //空表长度为0
      return OK;
  }
  ```
  {: id="20210122171651-mwdpgrn"}
- {: id="20210122171646-0qrfjf0"}取值
  {: id="20210122172116-duwluuo"}

  ```cpp
  Status GetElem(SqList L, int i, ElemType &e)
  {
      if (i < 1 || i > L.length)
          return ERROR;  //判断i值是否合理，若不合理，返回ERROR
      e = L.elem[i - 1]; //elem[i-1]单元存储第i个数据元素
      return OK;
  }
  ```
  {: id="20210122171711-ttocovh"}
- {: id="20210122171701-5bhvxeo"}查找
  {: id="20210122172116-bev0zqa"}

  ```cpp
  int LocateElem(SqList L, ElemType e)
  { //在顺序表L中查找值为e的数据元素，返回其序号
      for (int i = 0; i < L.length; i++)
          if (L.elem[i] == e)
              return i + 1; //查找成功，返回序号i+1
      return 0;             //查找失败，返回0
  }
  ```
  {: id="20210122172116-pyj38fz"}

  - {: id="20210122171901-mjszu6m"}((20210122235027-da94nkl "平均查找长度"))： $ASL=\frac{1}{n}\sum\limits_{i=1}^ni=\frac{n+1}{2}$
  - {: id="20210123092948-8piv4e2"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
  {: id="20210122171901-0w723jj"}
- {: id="20210122172255-3b5tn2h"}插入
  {: id="20210122172335-pa2igny"}

  ```cpp
  Status ListInsert(SqList &L, int i, ElemType e)
  { //在顺序表L中第i个位置插入新的元素e，i的合法范围是1<=i<=L.length+1
      if ((i < 1) || (i > L.length + 1))
          return ERROR; //i值不合法
      if (L.length == MAXSIZE)
          return ERROR; //当前存储空间已满
      for (int j = L.length - 1; j >= i - 1; j--)
          L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移
      L.elem[i - 1] = e;             //将新元素e放入第i个位置
      ++L.length;                    //表长加1
      return OK;
  }
  ```
  {: id="20210122172329-d0tqugs"}

  - {: id="20210122153334-1a0kta8"}插入时所需移动 ((20210118115037-6h08c9j "元素")) 的期望值
    - {: id="20210122153602-54fwzgb"}记作： $E_{ins}=\frac{1}{n+1}\sum\limits_{1=1}^{n+1}(n-i+1)=\frac{n}{2}$
    - {: id="20210122155328-swyaopq"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
    {: id="20210122153603-0dphilq"}
  {: id="20210122153411-jo0uy6n"}
- {: id="20210122155407-zv7ifyp"}删除
  {: id="20210122160927-mkn9n4n"}

  ```cpp
  Status ListDelete(SqList &L, int i)
  { //在顺序表L中删除第i个元素，i的合法范围是1<=i<=L.length
      if ((i < 1) || (i > L.length))
          return ERROR; //i值不合法
      if (L.length == 0)
          return ERROR; //当前存储空间已空
      for (int j = i; j <= L.length - 1; j++)
          L.elem[j - 1] = L.elem[j]; //被删除元素之后的元素前移
      --L.length;                    //表长减1
      return OK;
  }
  ```
  {: id="20210122155415-lzikhtu"}

  - {: id="20210122155919-2ijnrwj"}删除时所需移动 ((20210118115037-6h08c9j "元素")) 的期望值
    - {: id="20210122155919-0vl90z5"}记作： $E_{del}=\frac{1}{n}\sum\limits_{1=1}^{n}(n-i)=\frac{n-1}{2}$
    - {: id="20210122155919-h0qxiqb"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
    {: id="20210122155919-ek5fpl8"}
  {: id="20210121213342-kv35azy"}
{: id="20210122172329-bp1x1r8"}

## 线性表的链式表示和实现
{: id="20210122160959-vsxwjkq"}

### 单链表（线性链表）
{: id="20210122165817-v6jc9n3"}

- {: id="20210122205231-qlpdxw3"}定义：每个 ((20210122170313-wsturbw "结点")) 只包含一个 ((20210122170507-2f0rmf4 "指针域")) 的 ((20210122170513-jdlg2cq "链表"))
- {: id="20210123222507-xraq58g"}特点：顺序存取
- {: id="20210122210316-061c30k"}存储结构定义
  ```cpp
  typedef struct LNode
  {
      ElemType data;      //结点的数据域
      struct LNode *next; //结点的指针域
  } LNode, *LinkList;     //LinkList为指向结构体LNode的指针类型
  ```
  {: id="20210123221049-i23keth"}
{: id="20210122165817-bst0002"}

### 单链表中基本操作的实现
{: id="20210122171429-x8o9ygx"}

- {: id="20210122213437-byet950"}初始化
  {: id="20210123093944-vo9la21"}

  ```cpp
  Status InitList(LinkList &L)
  {                   //构造一个空的单链表L
      L = new LNode;  //生成新结点作为头结点，用头指针L指向头结点
      L->next = NULL; //头结点的指针域置空
      return OK;
  }
  ```
  {: id="20210122214508-dt3xy8u"}
- {: id="20210122213445-1g01ilf"}取值
  {: id="20210123093944-123if7q"}

  ```cpp
  Status GetElem(LinkList L, int i, ElemType &e)
  {                        //在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
      LNode *p = L->next;  //初始化，p指向首元结点
      int j = 1;           //计数器j初值赋为1
      while (p && (j < i)) //顺链域向后扫描，直到p为空或p指向第i个元素
      {
          p = p->next; //p指向下一个结点
          ++j;         //计数器j相应加1
      }
      if (!p || (j > i))
          return ERROR; //i值不合法i>n或i<=0
      e = p->data;      //取第i个结点的数据域
      return OK;
  }
  ```
  {: id="20210123093944-45hcp43"}

  - {: id="20210122232854-k2yvh2x"}((20210122235027-da94nkl "平均查找长度"))： $ASL=\frac{1}{n}\sum\limits_{i=1}^n(i-1)=\frac{n-1}{2}$
  - {: id="20210122233739-rglmn6y"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
  {: id="20210122232854-sn0v4yz"}
- {: id="20210122214607-vb72g2j"}查找
  {: id="20210123094219-nt1hp6j"}

  ```cpp
  LNode *LocateElem(LinkList L, ElemType e)
  {
      LNode *p = L->next;       //初始化，p指向首元结点
      while (p && p->data != e) //顺链域向后扫描，直到p为空或p所指结点的数据域等于e
          p = p->next;          //p指向下一个结点
      return p;                 //查找成功返回值为e的节点地址p，查找失败p为NULL
  }
  ```
  {: id="20210123093944-grbkpw4"}

  - {: id="20210123094037-a3we97u"}((20210122235027-da94nkl "平均查找长度"))：与 ((20210122213445-1g01ilf "取值")) 相同
  - {: id="20210123094151-hwzx3ps"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
  {: id="20210123094037-9ld9yhx"}
- {: id="20210122214615-iw8il9o"}插入
  {: id="20210123095623-5auyazt"}

  ```cpp
  Status ListInsert(LinkList &L, int i, ElemType e)
  { //在带头结点的单链表L中第i个位置插入值为e的新结点
      LNode *p = L;
      int j = 0;
      while (p && (j < i - 1)) //查找第i-1个结点，p指向该结点
      {
          p = p->next;
          ++j;
      }
      if (!p || j > i - 1)
          return ERROR;     //i值不合法i>n+1或i<1
      LNode *s = new LNode; //生成新结点*s
      s->data = e;          //将结点*s的数据域置为e
      s->next = p->next;    //将结点*s的指针域域指向结点a_i
      p->next = s;          //将结点*p的指针域指向结点*s
      return OK;
  }
  ```
  {: id="20210123093944-7jbeenw"}

  - {: id="20210123095611-67rtsmy"}((20210122235027-da94nkl "平均查找长度"))：与 ((20210122213445-1g01ilf "取值")) 相同
  - {: id="20210123095611-lo34e1k"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
  {: id="20210123095611-50jo6nj"}
- {: id="20210122214618-hui6iyf"}删除
  {: id="20210123100408-n2uq7cp"}

  ```cpp
  Status ListDelete(LinkList &L, int i)
  { //在带头结点的单链表L中，删除第i个元素
      LNode *p = L;
      int j = 0;
      while (p && (j < i - 1)) //查找第i-1个结点，p指向该结点
      {
          p = p->next;
          ++j;
      }
      if (!p || j > i - 1)
          return ERROR;   //i值不合法i>n+1或i<1
      LNode *q = p->next; //临时保存被删结点的地址以备释放
      p->next = q->next;  //改变删除结点前驱结点的指针域
      delete q;           //释放删除结点的空间
      return OK;
  }
  ```
  {: id="20210123093944-3gi6piu"}

  - {: id="20210123100402-g5r0plw"}((20210122235027-da94nkl "平均查找长度"))：与 ((20210122213445-1g01ilf "取值")) 相同
  - {: id="20210123100402-p9o9g1w"}((20210122234918-g8kd7s8 "平均时间复杂度"))： $O(n)$
  {: id="20210123100402-gh8fnb5"}
- {: id="20210122214634-ok1ahv8"}创建
  {: id="20210123093944-uhjbmkw"}

  - {: id="20210123100447-n554jgg"}前插法
    ```cpp
    void CreateList_H(LinkList &L, int n)
    { //逆位序输入n个元素的值，建立带表头结点的单链表L
        L = new LNode;
        L->next = NULL; //先建立一个带头结点的空链表
        for (int i = 0; i < n; i++)
        {
            LNode *p = new LNode; //生成新结点*p
            cin >> p->data;       //输入元素值付给新结点*p的数据域
            p->next = L->next;
            L->next = p; //将新结点*p插入到头结点之后
        }
    }
    ```
    {: id="20210123215004-doetbdw"}
  - {: id="20210123100512-hats6hl"}后插法
    ```cpp
    void CreateList_R(LinkList &L, int n)
    { //正位序输入n个元素的值，建立带表头结点的单链表L
        L = new LNode;
        L->next = NULL; //先建立一个带头结点的空链表
        LNode *r = L;   //尾指针r指向头结点
        for (int i = 0; i < n; i++)
        {
            LNode *p = new LNode; //生成新结点*p
            cin >> p->data;       //输入元素值付给新结点*p的数据域
            p->next = NULL;
            r->next = p; //将新结点*p插入尾结点*r之后
            r = p;       //r指向新的尾结点*p
        }
    }
    ```
    {: id="20210123215357-7f31h5k"}
  {: id="20210123100447-34jzr1o"}
{: id="20210122213102-1b3mqto"}

### 循环链表（Circular Linked List）
{: id="20210123100354-r2v1wny"}

- {: id="20210123220618-p5natq5"}定义：最后一个 ((20210122170313-wsturbw "结点")) 的 ((20210122170507-2f0rmf4 "指针域")) 指向 ((20210123221816-14pna6b "头结点")) 的 ((20210122165817-v6jc9n3 "单链表"))
- {: id="20210123223115-rgjx758"}操作：与 ((20210122165817-v6jc9n3 "单链表")) 基本一致
- {: id="20210123223415-qukk1gb"}特点
  - {: id="20210123224630-x9lojyo"}遍历时判断当前指针是否指向表尾结点的终止条件与 ((20210122165817-v6jc9n3 "单链表")) 不同
  - {: id="20210123224637-rnyr0ni"}设立尾指针可使表合并等操作简化
  {: id="20210123224631-2v1sh2w"}
{: id="20210123215423-1djpfaj"}

### 双向链表（Double Linked List）
{: id="20210123220740-vgcgkuh"}

- {: id="20210124174454-77jq20t"}定义
  - {: id="20210124174550-p3wk88a"}每个 ((20210122170313-wsturbw "结点")) 包含两个 ((20210122170507-2f0rmf4 "指针域")) 的 ((20210122170513-jdlg2cq "链表"))
  - {: id="20210124174553-8zsiy7v"}一个指向直接后继，一个指向直接前驱
  {: id="20210124174550-dgz901l"}
- {: id="20210124174559-ldzpsmn"}特点：查找直接前驱的执行时间为 $O(n)$
- {: id="20210124174643-8wglocy"}存储结构定义
  ```cpp
  typedef struct DuLNode
  {
      ElemType data;         //数据域
      struct DuLNode *prior; //指向直接前驱
      struct DuLNode *next;  //指向直接后继
  } DuLNode, *DuLinkList;
  ```
  {: id="20210124203723-tmbbrzg"}
- {: id="20210124203544-8qts81k"}操作
  - {: id="20210124203611-a6zzer1"}取值、查找
    - {: id="20210124203641-koohgpu"}与 ((20210122171429-x8o9ygx "单链表")) 相同
    {: id="20210124203641-pynmxfm"}
  - {: id="20210124203717-ok0uyk0"}插入
    ```cpp
    Status ListInsert_DuL(DuLinkList &L, int i, ElemType e)
    { //在带头结点的双向链表L中第i个位置之前插入元素e
        DuLNode *p;
        if (!(p = GetElem_DuL(L, i))) //在L中确定第i个元素的位置指针p
            return ERROR;             //p为NULL时，第i个元素不存在
        DuLNode *s = new DuLNode;     //生成新结点*s
        s->data = e;                  //将结点*s数据域置为e
        s->prior = p->prior;          //将结点*s插入L中
        p->prior->next = s;
        s->next = p;
        p->prior = s;
        return OK;
    }
    ```
    {: id="20210124203935-ct9a2q7"}
  - {: id="20210124203825-woj5nj1"}删除
  {: id="20210124203611-e9zlsxr"}
{: id="20210124174428-ebs8334"}


{: id="20210118114241-m4h7oed" type="doc"}
