- {: id="20210314215617-mob11h6"}### Spring框架两大核心机制
  {: id="20210314215617-uxecn4c" updated="20210314215627"}

  - {: id="20210314215629-dvm9302"}Spring是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。
    {: id="20210314215629-2bur0ze" updated="20210314220343"}

    - {: id="20210314220344-tcq9703"}MVC：Struts2、 Spring MVC
      {: id="20210314220344-v7z5jop" updated="20210314220346"}
    - {: id="20210314220347-1dkq2u7"}ORMapping：Hibernate. MyBatis, Spring Data
      {: id="20210314220347-cs9y9iw" updated="20210314220347"}
    {: id="20210314220350-jnatj4i"}
  - {: id="20210314220349-di4kj0z"}Spring核心技术
    {: id="20210314220349-2hcbprd"}

    - {: id="20210314220406-7wqcxx8"}控制反转（IoC：Inversion of Control）/依赖注入（D|:Dependency Injection）
      {: id="20210314220406-o49nlay" updated="20210314220439"}
    - {: id="20210314220440-johlpfq"}面向切面编程（AOP：Aspect Oriented Programming）
      {: id="20210314220440-zpzluwu" updated="20210314220446"}
    {: id="20210314220505-8ym8uts"}
  - {: id="20210314220504-65qfnxu"}控制反转
    {: id="20210314220504-klp9nfc" updated="20210314220514"}

    - {: id="20210314220514-yydg0pm"}什么是控制反转
      {: id="20210314220514-ztdv2ib"}

      - {: id="20210314220535-g3xexdu"}在传统的程序开发中，需要调用对象时，通常由调用者来创建被调用者的实例，即对象是由调用者主动new出来的。
        但在 Spring框架中创建对象的工作不再由调用者来完成，而是交给loc容器来创建，再推送给调用者，整个流程完成反转，所以是控制反转。
        {: id="20210314220535-zf3642c" updated="20210314220546"}
      {: id="20210314222424-4r1e21c"}
    - {: id="20210314222423-yhlxa63"}loC底层原理
      {: id="20210314222423-60zyh0r"}

      - {: id="20210314222437-m0g4n35"}读取配置文件，解析XML
        {: id="20210314222437-1vcn1vp" updated="20210314222446"}
      - {: id="20210314222441-zm2m72h"}通过反射机制实例化配置文件中所配置所有的bean
        {: id="20210314222441-nad52ak" updated="20210314222441"}
      {: id="20210314222656-vypwnti"}
    - {: id="20210314222656-ufxeyre"}scope作用域
      {: id="20210314222656-bxyk4v6"}

      - {: id="20210314222700-i7cq30l"}Spring管理的bean是根据sope来生成的，表示bean的作用域，共4种
        {: id="20210314222700-f1pjlzv" updated="20210314222708"}

        - {: id="20210314222708-rsuffaf"}singleton（缺省）：单例，表示通过 Spring容器获取的bean是唯一的
          {: id="20210314222708-gk6ztci" updated="20210314223003"}
        - {: id="20210314222716-84vu7un"}prototype：原型，表示通过 Spring容器获取的bean是不同的
          {: id="20210314222716-5v2qdiz" updated="20210314222719"}
        - {: id="20210314222725-got71yv"}request：请求，表示在一次HTTP请求内有效
          {: id="20210314222725-12x3zx1" updated="20210314222747"}
        - {: id="20210314222728-hdara14"}session：会话，表示在一个用户会话内有效
          {: id="20210314222728-33k15nm" updated="20210314222736"}
        {: id="20210314222803-b29d1nx"}
      - {: id="20210314222740-r8o3txu"}request和 session只适用于Web项目，大多数情况下，使用单例和原型较多。
        {: id="20210314222740-4jhue1b" updated="20210314222740"}
      - {: id="20210314223231-lfqv7li"}prototype模式当业务代码获取loC容器中的bean时， Spring才去调用无参构造创建对应的bean。
        {: id="20210314223231-ejkvtn8"}
      - {: id="20210314223235-457620u"}singleton模式无论业务代码是否获取loC容器中的bean, Spring在加载 spring. XML时就会创建bean
        {: id="20210314223235-nvk5786" updated="20210314223406"}
      {: id="20210314223407-hhdxlzc"}
    - {: id="20210314223406-0vdjgau"}Spring的继承
      {: id="20210314223406-q3qdadc"}

      - {: id="20210314223413-7fjhsph"}与Java的继承不同，Java是类层面的继承，子类可以继承父类的内部结构信息； Spring是对象层面的继承，子对象可以继承父对象的属性值
        {: id="20210314223413-wdwwo9p" updated="20210314223413"}
      {: id="20210314223413-rug90x0"}
    {: id="20210314220514-rl8b9qy"}
  {: id="20210314215910-a9yz81o" updated="20210314220346"}
{: id="20210314215524-s1vmtw8" updated="20210314223408"}

{: id="20210314215615-njk6fhn"}


{: id="20210314215524-0qa1um9" type="doc"}
